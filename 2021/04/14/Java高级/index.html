<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/tiger32_32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/tiger16_16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":"ture","show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="多线程基础概念程序：是为了完成特定任务，用某种语言编写的一组指令的集合，即指一段静态的代码，静态对象 进程：是程序的一次执行过程，或是正在运行的一个程序，是一个动态的过程，有它自身的产生、存在和消亡的过程——生命周期 线程：进程可进一步细化为线程，是一个程序内部的一条执行路径  线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器(pc) 一个进程中的多个线程共享相同的内存单元&#x2F;内存地">
<meta property="og:type" content="article">
<meta property="og:title" content="Java高级">
<meta property="og:url" content="http://example.com/2021/04/14/Java%E9%AB%98%E7%BA%A7/index.html">
<meta property="og:site_name" content="KKのblog">
<meta property="og:description" content="多线程基础概念程序：是为了完成特定任务，用某种语言编写的一组指令的集合，即指一段静态的代码，静态对象 进程：是程序的一次执行过程，或是正在运行的一个程序，是一个动态的过程，有它自身的产生、存在和消亡的过程——生命周期 线程：进程可进一步细化为线程，是一个程序内部的一条执行路径  线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器(pc) 一个进程中的多个线程共享相同的内存单元&#x2F;内存地">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wx1.sinaimg.cn/large/006GctFNgy1gpou3sn18dj30wr0dxtds.jpg">
<meta property="og:image" content="https://wx3.sinaimg.cn/large/006GctFNgy1gpp0xxqj5zj30xq0i6n8j.jpg">
<meta property="og:image" content="https://wx3.sinaimg.cn/large/006GctFNgy1gpyfcofp6aj30vk0gqguy.jpg">
<meta property="article:published_time" content="2021-04-14T03:48:35.000Z">
<meta property="article:modified_time" content="2021-05-01T15:46:08.957Z">
<meta property="article:author" content="KK">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wx1.sinaimg.cn/large/006GctFNgy1gpou3sn18dj30wr0dxtds.jpg">

<link rel="canonical" href="http://example.com/2021/04/14/Java%E9%AB%98%E7%BA%A7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java高级 | KKのblog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">KKのblog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签<span class="badge">1</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类<span class="badge">1</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档<span class="badge">5</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/14/Java%E9%AB%98%E7%BA%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/main.jpg">
      <meta itemprop="name" content="KK">
      <meta itemprop="description" content="记录生活中的点点滴滴~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KKのblog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java高级
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-14 11:48:35" itemprop="dateCreated datePublished" datetime="2021-04-14T11:48:35+08:00">2021-04-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-01 23:46:08" itemprop="dateModified" datetime="2021-05-01T23:46:08+08:00">2021-05-01</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>31k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <hr>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><p><strong>程序：</strong>是为了完成特定任务，用某种语言编写的一组指令的集合，即指一段<strong>静态的代码</strong>，静态对象</p>
<p><strong>进程：</strong>是程序的一次执行过程，或是正在运行的一个程序，是一个<strong>动态的过程</strong>，有它自身的产生、存在和消亡的过程——生命周期</p>
<p><strong>线程：</strong>进程可进一步细化为线程，是一个程序内部的一条执行路径</p>
<ul>
<li>线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器(pc)</li>
<li>一个进程中的多个线程共享相同的内存单元/内存地址空间—&gt;从同一堆中分配对象，可以访问相同的变量和对象（静态的）</li>
</ul>
<p><strong>并行：</strong>多个CPU同时执行多个任务</p>
<p><strong>并发：</strong>一个CPU（采用时间片）同时执行多个任务</p>
<span id="more"></span>

<h4 id="线程的声明周期"><a href="#线程的声明周期" class="headerlink" title="线程的声明周期"></a>线程的声明周期</h4><img src="https://wx1.sinaimg.cn/large/006GctFNgy1gpou3sn18dj30wr0dxtds.jpg" alt="线程的声明周期" style="zoom:67%;" />

<h4 id="Thread中常用的常量和方法"><a href="#Thread中常用的常量和方法" class="headerlink" title="Thread中常用的常量和方法"></a>Thread中常用的常量和方法</h4><p><strong>常用方法</strong></p>
<ol>
<li>start()：启动当前线程，调用当前线程的run()</li>
<li>run()：通常需要会重写Thread类中的此方法，将创建的线程要执行的操作声明再此方法中</li>
<li>currentThread()：静态方法，返回执行当前代码的线程</li>
<li>getName()：获取当前线程的名字</li>
<li>setName()：设置当前线程的名字</li>
<li>yield()：释放当前cpu的执行权（下一时刻cpu执行哪个线程随机）</li>
<li>join()：再线程a中调用线程b的join()，此时线程a就进入阻塞状态，直到线程b完全执行完以后，线程a才结束阻塞状态</li>
<li>stop()：<strong>已过时。</strong>当执行此方法时，强制结束当前线程</li>
<li>sleep(long millitime)：让当前线程“睡眠”指定的多少毫秒，在指定的时间内，当前线程时阻塞状态</li>
<li>isAlive()：判断当前线程是否存活</li>
</ol>
<p><strong>优先级</strong></p>
<ol>
<li><ul>
<li>MAX_PRIORITY:10</li>
<li>MIN_PRIORITY:1</li>
<li>NORM_PRIORITY:5 —&gt; 默认的优先级</li>
</ul>
</li>
<li><ul>
<li>getPriority()：获取线程的优先级</li>
<li>setPriority(int p)：设置线程的优先级</li>
<li>高优先级的线程要抢占低优先级线程cpu的执行权，但是只是从概率上来说，高优先级的线程高概率的情况下被执行，并不意味着只有当高优先级的线程执行完以后，低优先级的线程才执行</li>
</ul>
</li>
</ol>
<h4 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h4><p><em>Java中使用同步机制，来解决线程的安全问题</em></p>
<p><strong>1. 同步代码块</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 说明：1.操作共享数据的代码，即为需要被同步的代码 ---&gt;不能包含多了或少了</span></span><br><span class="line"><span class="comment"> *      2.共享数据：多个线程共同操作的变量，如买票的总票数</span></span><br><span class="line"><span class="comment"> *      3.同步监视器，俗称“锁”，任何一个类的对象，都可以充当锁</span></span><br><span class="line"><span class="comment"> *      要求：多个线程必须要共用同一把锁(this，当期类等等，看具体情况)</span></span><br><span class="line"><span class="comment"> * 		</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">    <span class="comment">// 需要被同步的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优缺点</p>
<ul>
<li>同步的方式，解决了线程的安全问题</li>
<li>但操作同步代码的时，只能有一个线程参与，其他线程等待，相当于是一个单线程的过程，效率低</li>
</ul>
<p><strong>2. 同步方法</strong></p>
<p>如果操作共享数据的代码完全的声明在一个方法中，可以将此方法声明为同步的</p>
<ol>
<li>同步的方法仍然涉及到同步监视器，只是不需要我们显式的申明</li>
<li>非静态的同步方法，同步监视器是：this；静态的同步方法，同步监视器是其本身</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>



<p><strong>3. Lock锁（JDK5.0新增）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">//run()里面的执行的操作</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// 调用锁定的方法：lock()</span></span><br><span class="line">    lock.lock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多线程中需要同步的代码</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">// 调用解锁的方法：unlock</span></span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>死锁</strong></p>
<ul>
<li>不同的线程分别占用对方所需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁（看双方握住的同步监视器是否交叉啥的）</li>
<li>出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处在阻塞状态，无法继续</li>
<li>使用同步时，需要避免出现死锁</li>
</ul>
<p><strong>线程通信</strong></p>
<ul>
<li>wait()：一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器</li>
<li>notify()：一点执行此方法，就会唤醒被wait的一个线程，如果有多个线程被wait，就唤醒优先级高的线程</li>
<li>notifyAll()：一旦执行此方法，就会唤醒所有被wait的线程</li>
<li>说明<ul>
<li>以上三个方法必须使用在同步代码块或同步方法中</li>
<li>以上三个方法的调用者必须是同步代码块或同步方法中的同步监视器，否则异常</li>
<li>都是定义在Object类中的方法</li>
</ul>
</li>
</ul>
<h3 id="创建多线程的方法"><a href="#创建多线程的方法" class="headerlink" title="创建多线程的方法"></a>创建多线程的方法</h3><h4 id="1-继承Thread类"><a href="#1-继承Thread类" class="headerlink" title="1. 继承Thread类"></a>1. 继承Thread类</h4><ol>
<li>创建一个继承于Thread类的子类</li>
<li>重写Thread类的run()—&gt;将此线程执行的操作声明在run()中</li>
<li>创建Thread类的子类的对象</li>
<li>通过此对象调用start()</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式1：继承与Thread类</span></span><br><span class="line">    <span class="comment">// 遍历100以内的所有偶数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        </span><br><span class="line">        MyThread t1 = <span class="keyword">new</span> MyThread();   </span><br><span class="line">        <span class="comment">// 启动当前线程，调用当前线程的run()</span></span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="comment">// 再启动一个线程，遍历100以内的偶数，，需要再创建一个线程的对象</span></span><br><span class="line">        MyThread t2 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        t2.start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如下操作仍然是在main线程中执行的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(i + <span class="string">&quot;main&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="comment">// 重写Thread类的run()---&gt;将此线程执行的操作声明在run()中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-实现Runnable接口"><a href="#2-实现Runnable接口" class="headerlink" title="2. 实现Runnable接口"></a>2. 实现Runnable接口</h4><ol>
<li>创建一个实现了Runnable接口的类</li>
<li>实现类去实现Runnable中的抽象方法</li>
<li>创建实现类的对象</li>
<li>将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</li>
<li>通过Thread类的对象调用start()</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MThread mThread = <span class="keyword">new</span> MThread();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(mThread);</span><br><span class="line">        <span class="comment">// 1.启动线程 2.调用当前线程的run()---&gt;调用了Runnable类型的的target的run方法</span></span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开发当中，优先选择实现Runnable接口的方式</p>
<ul>
<li>实现的方式没有类的单继承性的局限性</li>
<li>实现的方式更适合来处理多个线程有共享数据的情况</li>
<li>实际上，两种方法都是重写了<strong>Runnable</strong>里的run的抽象方法</li>
</ul>
<h4 id="3-实现Callable接口"><a href="#3-实现Callable接口" class="headerlink" title="3. 实现Callable接口"></a>3. 实现Callable接口</h4><ol>
<li>创建一个实现Callable的实现类</li>
<li>实现call方法，将此线程中需要执行的操作声明在call方法中，可以有返回值</li>
<li>创建Callable接口实现类的对象</li>
<li>将此Callable接口实现类的对象作为参数传递到FutureTask构造器中，创建FutureTask的对象</li>
<li>将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread的对象，并调用start()</li>
<li>futureTask.get()获取call()的返回值</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个实现Callable的实现类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumThread</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实现call方法，将此线程中需要执行的操作声明在call方法中，可以有返回值</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadNew</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建Callable接口实现类的对象</span></span><br><span class="line">        NumThread numThread = <span class="keyword">new</span> NumThread();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将此Callable接口实现类的对象作为参数传递到FutureTask构造器中，创建FutureTask的对象</span></span><br><span class="line">        FutureTask futureTask = <span class="keyword">new</span> FutureTask(numThread);</span><br><span class="line">        <span class="comment">// 将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread的对象，并调用start()</span></span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值</span></span><br><span class="line">            Object sum = futureTask.get();</span><br><span class="line">            System.out.println(sum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>比实现Runnable接口强大原因</strong></p>
<ul>
<li>call()可以有返回值</li>
<li>call()可以抛出异常，被外面的操作捕获，获取异常的信息</li>
<li>Callable是支持泛型的</li>
</ul>
<h4 id="4-使用线程池"><a href="#4-使用线程池" class="headerlink" title="4. 使用线程池"></a>4. 使用线程池</h4><ol>
<li>提供指定线程数量的线程池</li>
<li>执行指定的线程的操作，需要提供实现Runnable接口或Callable接口实现类的对象</li>
<li>关闭连接池</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Runnable接口的实现类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Callable接口的实现类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumThread1</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实现call方法，将此线程中需要执行的操作声明在call方法中，可以有返回值</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：&quot;</span> + i);</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 提供指定线程数量的线程池</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 执行指定的线程的操作，需要提供实现Runnable接口或Callable接口实现类的对象</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> NumberThread());<span class="comment">// 适用于Runnable</span></span><br><span class="line">        service.submit(<span class="keyword">new</span> NumThread1());<span class="comment">// 适用于Callable</span></span><br><span class="line">        service.shutdown(); <span class="comment">// 关闭连接池</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优点</strong></p>
<ul>
<li>提高响应速度，减少了创建新线程的时间</li>
<li>降低资源消耗</li>
<li>便于线程管理（核心池的大小，最大线程数等等）</li>
</ul>
<hr>
<h2 id="Java常用类"><a href="#Java常用类" class="headerlink" title="Java常用类"></a>Java常用类</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p><strong>说明</strong></p>
<ol>
<li>使用一对” “一起来表示</li>
<li>String声明为final的，不可被继承</li>
<li>String实现了Serializable接口，表示字符串是支持序列化的</li>
<li>String实现了Comparable接口，表示String可以比较大小</li>
<li>String内部定义了final char[] value用于存储字符串的数据，代表不可变的字符序列（<strong>不可变性</strong>）<ul>
<li>对字符串重新赋值、连接操作、replace()方法修字符等，只要对原字符串进行修改都是需要重新指定内存区域赋值</li>
</ul>
</li>
<li>通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在<strong>字符串常量池</strong>中<ul>
<li>字面量（literal）是用于表达<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%BA%90%E4%BB%A3%E7%A0%81/3969">源代码</a>中一个固定值的表示法</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;abc&quot;</span>; <span class="comment">// 字面量的定义方式</span></span><br></pre></td></tr></table></figure>

<ol start="7">
<li>字符串常量池中不会储存相同内容的字符串</li>
</ol>
<p><strong>实例化方式</strong></p>
<ul>
<li>通过字面量定义的方式</li>
<li>通过new+构造器的方式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 通过字面量定义的方式，此时的s1和s2的数据abc声明在方法区中的字符串常量池中</span></span><br><span class="line">    String s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    String s2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="comment">// 通过new+构造器的方式，此时s3和s4保存的地址值，是在堆空间中开辟空间后对应的地址值</span></span><br><span class="line">    String s3 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    String s4 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(s1 == s2); <span class="comment">// true</span></span><br><span class="line">    System.out.println(s3 == s4); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<img src="https://wx3.sinaimg.cn/large/006GctFNgy1gpp0xxqj5zj30xq0i6n8j.jpg" alt="字符串对象储存方式" style="zoom:50%;" />



<p><strong>例子</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    String s2 = <span class="string">&quot;def&quot;</span>;</span><br><span class="line"></span><br><span class="line">    String s3 = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line">    String s4 = <span class="string">&quot;abc&quot;</span> + <span class="string">&quot;def&quot;</span>;</span><br><span class="line">    String s5 = s1 + <span class="string">&quot;def&quot;</span>;</span><br><span class="line">    String s6 = <span class="string">&quot;abc&quot;</span> + s2;</span><br><span class="line">    String s7 = s1 + s2;</span><br><span class="line">    String s8 = (s1 + s2).intern(); <span class="comment">// 调常量池已有的字符串</span></span><br><span class="line"></span><br><span class="line">    System.out.println(s3 == s4); <span class="comment">// true</span></span><br><span class="line">    System.out.println(s3 == s5); <span class="comment">// false</span></span><br><span class="line">    System.out.println(s3 == s6); <span class="comment">// false</span></span><br><span class="line">    System.out.println(s3 == s7); <span class="comment">// false</span></span><br><span class="line">    System.out.println(s3 == s8); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>说明</strong></p>
<ul>
<li>常量和常量的拼接结果在常量池，且常量池中不会存在相同内容的常量</li>
<li>只要其中有一个是变量，结果就在堆中（跟new类似）</li>
<li>如果拼接的结果调用intern()方法，返回值就在常量池中</li>
</ul>
<p><strong>String和char[]之间互相转换</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// String---&gt;char[]：调用String的toCharArray()</span></span><br><span class="line">    String s = <span class="keyword">new</span> String(<span class="string">&quot;abc123&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span>[] charArray = s.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; charArray.length; i++) &#123;</span><br><span class="line">        System.out.println(charArray[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// char[]---&gt;String，调用String的构造器</span></span><br><span class="line">    <span class="keyword">char</span>[] arr = <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line">    String s1 = <span class="keyword">new</span> String(arr);</span><br><span class="line">    System.out.println(s1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>String和byte[]之间互相转换</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//解码集和编码集要一致         </span></span><br><span class="line">    <span class="comment">// String---&gt;byte[]:调用String的getBytes()</span></span><br><span class="line">    String s = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = s.getBytes();<span class="comment">// 使用默认的字符集进行编码</span></span><br><span class="line">    System.out.println(Arrays.toString(bytes));<span class="comment">// [97, 98, 99]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// byte[]---&gt;String，调用String的构造器</span></span><br><span class="line">    String s1 = <span class="keyword">new</span> String(bytes); <span class="comment">// 使用默认的字符集进行解码</span></span><br><span class="line">    System.out.println(s1); <span class="comment">// abc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="StringBuffer和StringBuilder"><a href="#StringBuffer和StringBuilder" class="headerlink" title="StringBuffer和StringBuilder"></a>StringBuffer和StringBuilder</h3><p><strong>三者的关系</strong></p>
<ul>
<li>String：不可变的字符序列，底层</li>
<li>StringBuffer：可变的字符序列，线程安全的，效率低</li>
<li>StringBuilder：可变的字符序列，线程不安全的，效率高（jdk5.0新增）</li>
</ul>
<p><strong>源码分析</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(); <span class="comment">// char[] value = new char[0];</span></span><br><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>); <span class="comment">// char[] value = new char[]&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;;</span></span><br><span class="line"></span><br><span class="line">StringBuffer sb1 = <span class="keyword">new</span> StringBuffer(); <span class="comment">// char[] value = new char[16]; // 底层创建了一个长度为16的数组</span></span><br><span class="line">sb1.append(<span class="string">&#x27;a&#x27;</span>); <span class="comment">// value[0] = &#x27;a&#x27;;</span></span><br><span class="line">sb1.append(<span class="string">&#x27;b&#x27;</span>); <span class="comment">// value[1] = &#x27;b&#x27;;</span></span><br><span class="line">StringBuffer sb2 = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;abc&quot;</span>); <span class="comment">// char[] value = new char[&quot;abc&quot;.length() + 16];</span></span><br></pre></td></tr></table></figure>

<p><em>注意</em></p>
<ul>
<li>System.out.println(sb.length()); // 3</li>
<li>扩容：如果要添加的数据底层数组盛不下，那就需要扩容底层的数组；默认情况下，扩容为原来容量的2倍 + 2，同时将原有数组的元素复制到新的数组中</li>
<li>开发中，已知大概数组大小，可以提前使用StringBuffer(int capacity)造个大小差不多的数组，避免复制，提高效率</li>
</ul>
<p><strong>常用方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StringBuffer <span class="title">append</span><span class="params">(xxx)</span>:用于字符串的拼接</span></span><br><span class="line"><span class="function">StringBuffer <span class="title">delete</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span>:删除指定位置的内容</span></span><br><span class="line"><span class="function">StringBuffer <span class="title">replace</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, String str)</span>:把[start, end]位置替换成str </span></span><br><span class="line"><span class="function">StringBuffer <span class="title">insert</span><span class="params">(<span class="keyword">int</span> offset， xxx)</span>:在指定位置插入xxx    </span></span><br><span class="line"><span class="function">StringBuffer <span class="title">reverse</span><span class="params">(xxx)</span>:把当前字符串序列反转   </span></span><br></pre></td></tr></table></figure>



<h3 id="有关Date的类"><a href="#有关Date的类" class="headerlink" title="有关Date的类"></a>有关Date的类</h3><h4 id="JDK1-8之前"><a href="#JDK1-8之前" class="headerlink" title="JDK1.8之前"></a>JDK1.8之前</h4><ul>
<li><strong>java.util.Date</strong></li>
<li><strong>java.sql.Date</strong>（是util.Date的子类）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateTimeTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.System类中的currentTimeMillis()</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 返回当前时间与1970年1月1日0：0：0之间以毫秒为单位的时间差</span></span><br><span class="line">        <span class="comment">// 称为时间戳</span></span><br><span class="line">        <span class="keyword">long</span> l = System.currentTimeMillis();</span><br><span class="line">        System.out.println(l);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. java.util.Date</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 构造器1：date()，创建了一个对应当前时间的Date对象</span></span><br><span class="line">        Date date1 = <span class="keyword">new</span> Date();</span><br><span class="line">        System.out.println(date1.toString()); <span class="comment">// Mon Apr 19 22:46:43 CST 2021</span></span><br><span class="line">        System.out.println(date1.getTime()); <span class="comment">// 获取当前date对象的时间戳</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//构造器2：创建指定毫秒数的date对象</span></span><br><span class="line">        Date date2 = <span class="keyword">new</span> Date(<span class="number">1618843665359L</span>);</span><br><span class="line">        System.out.println(date2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造器：java.sql.Date</span></span><br><span class="line">        java.sql.Date date3 = <span class="keyword">new</span> java.sql.Date(<span class="number">1618843665359L</span>);</span><br><span class="line">        System.out.println(date3);</span><br><span class="line">        <span class="comment">// java.sql.Date---&gt;java.util.Date</span></span><br><span class="line">        java.sql.Date date4 = <span class="keyword">new</span> java.sql.Date(date2.getTime()); <span class="comment">// 获取util.Date对象的时间戳，再放到sql.Date类的构造器中</span></span><br><span class="line">        System.out.println(date4.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>SimpleDateFormat</strong></li>
</ul>
<p><em>对SimpleDateFormat对日期Date类的格式化和解析</em>(解析和格式化的标准要统一！)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFormatDateTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestSimpleDateFormat</span><span class="params">()</span> <span class="keyword">throws</span> ParseException </span>&#123;<span class="comment">// 要抛异常</span></span><br><span class="line">        <span class="comment">// 实例化SimpleDateFormat:使用默认的构造器</span></span><br><span class="line">        SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat();</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line"><span class="comment">//        System.out.println(date);</span></span><br><span class="line">        <span class="comment">// 格式化：日期---&gt;字符串</span></span><br><span class="line">        String format = sdf.format(date);</span><br><span class="line">        System.out.println(format);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 格式化逆过程，字符串---&gt;日期</span></span><br><span class="line">        String str = <span class="string">&quot;21-7-21 上午10:16&quot;</span>;</span><br><span class="line">        Date parse = sdf.parse(str);</span><br><span class="line">        System.out.println(parse);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以指定的时间格式解析和格式化，调用带参的构造器，具体看API内容</span></span><br><span class="line">        SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line">        String format1 = simpleDateFormat.format(date);</span><br><span class="line">        System.out.println(format1); <span class="comment">// 2021-04-21 09:28:22</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Calendar</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Calendar日历类（抽象类）的使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CalendarTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1.实例化</span></span><br><span class="line">    <span class="comment">// 方式1：创建子类GregorianCalendar的对象</span></span><br><span class="line">    <span class="comment">// 方式2：调用其静态方法getInstance</span></span><br><span class="line">    Calendar instance = Calendar.getInstance();</span><br><span class="line">    <span class="comment">// 2.常用方法</span></span><br><span class="line">    <span class="comment">// get()</span></span><br><span class="line">    <span class="keyword">int</span> days = instance.get(Calendar.DAY_OF_YEAR);</span><br><span class="line">    System.out.println(days);</span><br><span class="line">    <span class="comment">// set()</span></span><br><span class="line">    instance.set(Calendar.DAY_OF_YEAR, <span class="number">165</span>);</span><br><span class="line">    days = instance.get(Calendar.DAY_OF_YEAR);</span><br><span class="line">    System.out.println(days);</span><br><span class="line">    <span class="comment">// add(),在原有基础上加了多少</span></span><br><span class="line">    instance.add(Calendar.DAY_OF_WEEK, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getTime()日历类---&gt;Date类</span></span><br><span class="line">    Date date = instance.getTime();</span><br><span class="line">    System.out.println(date);</span><br><span class="line">    <span class="comment">// setTime()Date类---&gt;日历类</span></span><br><span class="line">    instance.setTime(date);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="JDK1-8新增"><a href="#JDK1-8新增" class="headerlink" title="JDK1.8新增"></a>JDK1.8新增</h4><ul>
<li><strong>LocalDate、LocalTime、LocalDateTime</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LocalTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// LocalDate,LocalTime,LocalDateTime使用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// now()获取当前的日期和时间</span></span><br><span class="line">    LocalDate localDate = LocalDate.now();<span class="comment">// 2021-04-21</span></span><br><span class="line">    LocalTime localTime = LocalTime.now();<span class="comment">// 10:13:07.270</span></span><br><span class="line">    LocalDateTime localDateTime = LocalDateTime.now();<span class="comment">// 2021-04-21T10:13:07.270</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// of():设定指定的年月日时分秒，没有偏移量</span></span><br><span class="line">    LocalDateTime dateTime = LocalDateTime.of(<span class="number">2021</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">45</span>);</span><br><span class="line">    System.out.println(dateTime);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getXxx() 获取相应的一些属性</span></span><br><span class="line">    System.out.println(localDateTime.getDayOfMonth());</span><br><span class="line">    <span class="comment">// withXxx,设置相应的属性，会返回一个新对象，体现了不可变性</span></span><br><span class="line">    LocalDate date = localDate.withDayOfMonth(<span class="number">13</span>);</span><br><span class="line">    System.out.println(date);</span><br><span class="line">    System.out.println(localDate);</span><br><span class="line">    <span class="comment">// plusXxx</span></span><br><span class="line">    LocalDate plus = localDate.plusDays(<span class="number">12</span>);</span><br><span class="line">    System.out.println(plus);</span><br><span class="line">    System.out.println(localDate);</span><br><span class="line">    <span class="comment">// minusXxx</span></span><br><span class="line">    LocalDate minus = localDate.minusDays(<span class="number">12</span>);</span><br><span class="line">    System.out.println(minus);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Instant</strong></li>
</ul>
<p><em>类似于java.util.Date类</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InstantTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// now()获取本初子午线对用的标准时间</span></span><br><span class="line">    Instant instant = Instant.now();</span><br><span class="line">    System.out.println(instant);</span><br><span class="line">    <span class="comment">// 添加时间的偏移量</span></span><br><span class="line">    OffsetDateTime offsetDateTime = instant.atOffset(ZoneOffset.ofHours(<span class="number">8</span>));</span><br><span class="line">    System.out.println(offsetDateTime);</span><br><span class="line">    <span class="comment">// 获取自1970年0：0：0开始的毫秒数 ---&gt;Date类的gettime()</span></span><br><span class="line">    <span class="keyword">long</span> l = instant.toEpochMilli();</span><br><span class="line">    System.out.println(l);</span><br><span class="line">    <span class="comment">// ofEpochMilli,通过给定的毫秒数，获取Instant实例 ---&gt;Date(millis)</span></span><br><span class="line">    Instant ofEpochMilli = Instant.ofEpochMilli(<span class="number">161897569439L</span>);</span><br><span class="line">    System.out.println(ofEpochMilli);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Comparable（自然排序）"><a href="#Comparable（自然排序）" class="headerlink" title="Comparable（自然排序）"></a>Comparable（自然排序）</h3><ul>
<li><p>像String、包装类实现了Comparable接口，重写了compareTo(obj)的方法，给出了比较两个对象的大小的方式（一般是从小到大排），用Arrays.sort(Object o)实现排序</p>
</li>
<li><p>重写compareTo(obj)规则：</p>
<ul>
<li>如果当前对象this大于形参对象obj，返回正整数，小于返回负整数，等于返回零</li>
</ul>
</li>
<li><p>对于自定义类来说，如果需要排序，可以让自定义类实现Coparable接口，重写compareTo(obj)的方法，在方法中指明如何排序</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Goods[] arr = <span class="keyword">new</span> Goods[<span class="number">4</span>];</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;lenovo&quot;</span>, <span class="number">3544</span>);</span><br><span class="line">    arr[<span class="number">1</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;mi &quot;</span>, <span class="number">5434</span>);</span><br><span class="line">    arr[<span class="number">2</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;Huawei&quot;</span>, <span class="number">5434</span>);</span><br><span class="line">    arr[<span class="number">3</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;dell&quot;</span>, <span class="number">8534</span>);</span><br><span class="line"></span><br><span class="line">    Arrays.sort(arr);</span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">    <span class="comment">// out: [Goods&#123;name=&#x27;lenovo&#x27;, price=3544.0&#125;, Goods&#123;name=&#x27;Huawei&#x27;, price=5434.0&#125;,</span></span><br><span class="line">    <span class="comment">// Goods&#123;name=&#x27;mi &#x27;, price=5434.0&#125;, Goods&#123;name=&#x27;dell&#x27;, price=8534.0&#125;]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//*****************************************************************</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Goods</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line">    <span class="comment">// 实现了Comparable的接口里的compareTo的方法</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Goods</span><span class="params">(String name, <span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Goods&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, price=&quot;</span> + price +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> <span class="keyword">throws</span> RuntimeException </span>&#123;</span><br><span class="line">        <span class="comment">// 方式1</span></span><br><span class="line">        <span class="keyword">if</span>(o <span class="keyword">instanceof</span> Goods)&#123;</span><br><span class="line">            Goods goods = (Goods) o;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.price &gt; goods.price)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.price &lt; goods.price)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//return 0;</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.name.compareTo(goods.name);<span class="comment">// 如果价钱一样，按照姓名排序</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 方式2</span></span><br><span class="line">            <span class="comment">//Double.compare(this.price, goods.price);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;传入的数据类型不一致！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="Comparator（定制排序）"><a href="#Comparator（定制排序）" class="headerlink" title="Comparator（定制排序）"></a>Comparator（定制排序）</h3><ul>
<li>元素的类型没有实现Comparable接口而又不方便修改代码，或实现了Comparable接口的排序规则不适合当前的操作，可以考虑使用Comparator的对象来排序</li>
<li>重写compare(Object o1, Object o2)方法，比较o1和o2的大小，如果方法返回正整数，o1&gt;o2；返回负整数，o1&lt;o2；返回零，表示二者相等</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// Goods类结构和上面一样</span></span><br><span class="line">    Goods[] arr = <span class="keyword">new</span> Goods[<span class="number">5</span>];</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;lenovo&quot;</span>, <span class="number">3544</span>);</span><br><span class="line">    arr[<span class="number">1</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;mi &quot;</span>, <span class="number">5434</span>);</span><br><span class="line">    arr[<span class="number">2</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;Huawei&quot;</span>, <span class="number">5434</span>);</span><br><span class="line">    arr[<span class="number">3</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;dell&quot;</span>, <span class="number">8534</span>);</span><br><span class="line">    arr[<span class="number">4</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;dell&quot;</span>, <span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">    Arrays.sort(arr, <span class="keyword">new</span> Comparator() &#123;<span class="comment">// 匿名类的匿名对象</span></span><br><span class="line">        <span class="comment">// 指明商品比较大小的方式，按照产品名称从低到高排序，再按价格从高到低排序</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> Object &amp;&amp; o2 <span class="keyword">instanceof</span> Object)&#123;</span><br><span class="line">                Goods g1 = (Goods) o1;</span><br><span class="line">                Goods g2 = (Goods) o2;</span><br><span class="line">                <span class="keyword">if</span>(g1.getName().equals(g2.getName()))&#123;</span><br><span class="line">                    <span class="keyword">return</span> -Double.compare(g1.getPrice(), g2.getPrice()); <span class="comment">// 加负号使得其从高往低排</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> g1.getName().compareTo(g2.getName());<span class="comment">// 字符串从低往高排</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;传入的数据类型不一致！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Comparable和Comparator对比</strong></p>
<p>Comparable接口的方式一旦确定，保证Comparable接口实现类对象在任何位置都可以比较大小；而Comparator接口属于临时性的比较</p>
<hr>
<h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><ul>
<li>类的对象只有有限个，确定的，称此类为枚举类</li>
<li>需要定义一组常量时，强烈建议使用枚举类</li>
<li>如果枚举类只有一个对象，则可以作为一种单例模式的事项方式</li>
</ul>
<h3 id="定义枚举类"><a href="#定义枚举类" class="headerlink" title="定义枚举类"></a>定义枚举类</h3><p>方式一：JDK5.0之前，自定义枚举类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeasonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Season summer = Season.SUMMER;</span><br><span class="line">        System.out.println(summer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义枚举类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Season</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1.声明Season对象的属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.私有化类的构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Season</span><span class="params">(String seasonName, String seasonDesc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="keyword">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.提供当前枚举类的多个对象，public static final的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season SPRING = <span class="keyword">new</span> Season(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;春暖花开&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season SUMMER = <span class="keyword">new</span> Season(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;夏日炎炎&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season AUTUMN = <span class="keyword">new</span> Season(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;秋高气爽&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season WINTER = <span class="keyword">new</span> Season(<span class="string">&quot;冬天&quot;</span>, <span class="string">&quot;寒冬凛冽&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.其他要求，获取枚举类对象的属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeasonName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeasonDesc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Season&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;seasonName=&#x27;&quot;</span> + seasonName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, seasonDesc=&#x27;&quot;</span> + seasonDesc + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方式二：JDK5.0，可以使用enum关键字定义枚举类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeasonTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Season1 spring = Season1.SPRING;</span><br><span class="line">        System.out.println(spring); <span class="comment">// SPRING,不是继承于Object类</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用enum关键字枚举类</span></span><br><span class="line"><span class="comment">// 定义的枚举类默认继承于java.lang.Enum类</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Season1</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 枚举类对象定义在最前面</span></span><br><span class="line">    <span class="comment">// 1.提供当前枚举类的对象，多个对象之间用&quot;,&quot;隔开，末尾对象&quot;;&quot;结束</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;春暖花开&quot;</span>),</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;夏日炎炎&quot;</span>),</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;秋高气爽&quot;</span>),</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>, <span class="string">&quot;寒冬凛冽&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.声明Season对象的属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.私有化类的构造器，并给对象属性赋值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Season1</span><span class="params">(String seasonName, String seasonDesc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="keyword">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.其他要求，获取枚举类对象的属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeasonName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeasonDesc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Enum类的常用方法"><a href="#Enum类的常用方法" class="headerlink" title="Enum类的常用方法"></a>Enum类的常用方法</h3><ul>
<li>values()方法：返回枚举类型的对象数组，该方法可以很方便的遍历所有的枚举值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Season1[] values = Season1.values();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">    System.out.println(values[i]);</span><br><span class="line">&#125;<span class="comment">// SPRING SUMMER AUTUMN WINTER</span></span><br></pre></td></tr></table></figure>

<ul>
<li>valueOf(String str)：可以把一个字符串转为对应的枚举类对象，要求字符串必须是枚举类对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// valueOf(String str),返回枚举类中对象名是objName的对象</span></span><br><span class="line"><span class="comment">// 如果没有objName的对象，会抛异常</span></span><br><span class="line">Season1 winter = Season1.valueOf(<span class="string">&quot;WINTER&quot;</span>);</span><br><span class="line">System.out.println(winter); <span class="comment">// WINTER</span></span><br></pre></td></tr></table></figure>

<ul>
<li>toString()：返回当前枚举类对象常量的名称</li>
</ul>
<h3 id="使用enum定义枚举类实现接口"><a href="#使用enum定义枚举类实现接口" class="headerlink" title="使用enum定义枚举类实现接口"></a>使用enum定义枚举类实现接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Info</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Season1</span> <span class="keyword">implements</span> <span class="title">Info</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 枚举类对象定义在最前面</span></span><br><span class="line">    <span class="comment">// 1.提供当前枚举类的对象，多个对象之间用&quot;,&quot;隔开，末尾对象&quot;;&quot;结束</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;春暖花开&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; <span class="comment">// 匿名内部类</span></span><br><span class="line">            System.out.println(<span class="string">&quot;春天在哪里啊？&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;夏日炎炎&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;夏天在哪里啊？&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;秋高气爽&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;秋天在哪里啊？&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>, <span class="string">&quot;寒冬凛冽&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;冬天在哪里啊？&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><ul>
<li>JDK5.0新增</li>
<li>代码中的特殊标记，在编译、类加载、运行时被读取，并执行相应的处理</li>
<li>在JavaEE/Android中占据了重要的角色</li>
<li><strong>框架 = 注解 + 反射 + 设计模式</strong></li>
</ul>
<p><strong>示例</strong></p>
<ul>
<li>生成文档相关的注解</li>
<li>在编译时进行格式检查（JDK内置的三个基本注解）</li>
<li>跟踪代码依赖性，实现替代配置文件功能</li>
</ul>
<p><strong>自定义注解</strong></p>
<ul>
<li>注解声明为@interface</li>
<li>内部定义成员，通常使用value表示</li>
<li>可以指定成员的默认值，使用default定义</li>
<li>如果自定义注解没有成员，表明是一个标识作用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>自定义注解必须配上注解的信息处理流程（使用反射）才有意义</li>
</ul>
<p><strong>元注解</strong></p>
<p><em>对现有的注解进行解释说明的注解</em></p>
<ul>
<li>Retention：指定所修饰的Annotation的生命周期，SOURCE\CLASS（默认行为）\RUNTIME，只有声明为RUNTIME生命周期的注解，才能通过反射获取</li>
<li>Target：用于指定被修饰的的Annotation能用于修饰哪些程序元素</li>
</ul>
<p><strong><strong><strong><strong><strong><strong><strong><strong><strong>以下元注解使用频率较低</strong></strong></strong></strong></strong></strong></strong></strong></strong></p>
<ul>
<li>Documented：用于指定被元Annotation修饰的Annotation类将被Javadoc工具提取为文档</li>
<li>Inherited：被它修饰的Annotation将具有继承性（类的子类也会有那个Annotation）</li>
</ul>
<h3 id="类型注解、可重复注解"><a href="#类型注解、可重复注解" class="headerlink" title="类型注解、可重复注解"></a><del>类型注解、可重复注解</del></h3><p>一脸懵逼，等学完反射再来看，P510</p>
<hr>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li>集合、数组都是对多个数据进行存储操作的结构，简称Java容器</li>
<li>数组在存储多个数据方面的特点<ul>
<li>一旦初始化以后，其长度就确定了，不能修改</li>
<li>数组一旦定义好，其元素的类型就确定了，比如：String[] arr,Object[] arr</li>
<li>数组中提供的方法非常有限，对于添加、删除、插入数据等操作非常不便，同时效率不高</li>
<li>获取数组中实际元素的个数的需求，没有现成的属性或方法可用</li>
<li>数组存储数据的特点：有序、可重复</li>
</ul>
</li>
</ul>
<h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><p><em>Java集合分为Collection和Map两种体系</em></p>
<ul>
<li>Collection接口：单列集合，用来存储一个一个的对象<ul>
<li>List接口：存储有序的、可重复的数据   —-&gt;”动态“数组<ul>
<li>ArrayList：作为List接口的主要实现类；线程不安全的，效率高；使用Object[]存储</li>
<li>LinkedList：底层使用双向链表存储，对于频繁的插入、删除操作，效率比ArrayList高</li>
<li>Vector：作为List接口的古老实现类；线程安全的，效率低；使用Object[]存储</li>
</ul>
</li>
<li>Set接口：存储无序的、不可重复的数据   —-&gt;高中讲的”集合“<ul>
<li>HashSet：作为Set接口的主要实现类；线程不安全的；可以存储null值<ul>
<li>LinkedHashSet：作为HashSet的子类；遍历其内部数据时，可以按照添加的顺序遍历</li>
</ul>
</li>
<li>TreeSet：可以按照添加的对象的指定属性，进行排序</li>
</ul>
</li>
</ul>
</li>
<li>Map接口：双列集合，用来存储一对(key - value)一对的数据    —-&gt;高中讲的”函数“：y = f(x)<ul>
<li>HashMap：作为Map的主要实现类；线程不安全的，效率高；存储null的key和value<ul>
<li>LinkedHashMap：保证在遍历map元素时，可以按照添加的顺序实现遍历（对于频繁的遍历操作，此类执行效率高于HashMap）</li>
</ul>
</li>
<li>TreeMap：保证按照添加的key-value对进行排序，实现排序遍历（按照key排序），底层用的红黑树</li>
<li>Hashtable：作为古老的实现类；线程安全的，效率低；不能存储null的key和value<ul>
<li>Properties：常用来处理配置文件，key和value都是String类型</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h3><h4 id="Collection接口继承树"><a href="#Collection接口继承树" class="headerlink" title="Collection接口继承树"></a>Collection接口继承树</h4><img src="https://wx3.sinaimg.cn/large/006GctFNgy1gpyfcofp6aj30vk0gqguy.jpg" alt="Collection接口继承树" style="zoom: 67%;" />





<h4 id="Collection接口中常用方法"><a href="#Collection接口中常用方法" class="headerlink" title="Collection接口中常用方法"></a>Collection接口中常用方法</h4><p><em>向Collection接口的实现类的对象中添加数据obj时，要求obj所在类要重写equals()方法</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 使用ArrayList测试，因为接口中全是抽象方法</span></span><br><span class="line">        Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.add(Object e)：将元素e添加到集合coll中</span></span><br><span class="line">        coll.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;BB&quot;</span>);</span><br><span class="line">        coll.add(<span class="number">123</span>); <span class="comment">// 自动装箱</span></span><br><span class="line">        coll.add(<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.size()：获取添加的元素的个数</span></span><br><span class="line">        System.out.println(coll.size()); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.addAll(Collection coll1)：将coll1集合中的元素添加到当前的集合中</span></span><br><span class="line">        Collection coll1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        coll1.add(<span class="number">456</span>);</span><br><span class="line">        coll1.add(<span class="string">&quot;CC&quot;</span>);</span><br><span class="line">        coll.addAll(coll1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.clear()：清空集合元素</span></span><br><span class="line">        coll.clear();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.isEmpty()：判断当前集合是否为空</span></span><br><span class="line">        System.out.println(coll.isEmpty()); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.contains()：判断当前集合中是否包含obj</span></span><br><span class="line">        <span class="comment">// 在判断时，会调用obj对象所在类的equals()方法</span></span><br><span class="line">        coll.add(<span class="keyword">new</span> String(<span class="string">&quot;Tom&quot;</span>));</span><br><span class="line">        coll.add(<span class="number">123</span>);</span><br><span class="line">        <span class="keyword">boolean</span> contains = coll.contains(<span class="keyword">new</span> String(<span class="string">&quot;Tom&quot;</span>));</span><br><span class="line">        System.out.println(contains);  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.containsAll(Collection coll1)：判断形参当中的所有元素是否都存在于当前集合中</span></span><br><span class="line">        Collection coll1 = Arrays.asList(<span class="number">123</span>);</span><br><span class="line">        System.out.println(coll.containsAll(coll1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 1.remove(Objcet obj)</span></span><br><span class="line">        Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        coll.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">        coll.add(<span class="number">123</span>);</span><br><span class="line">        <span class="keyword">boolean</span> remove = coll.remove(<span class="number">123</span>);</span><br><span class="line">        System.out.println(remove); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.removeAll(Collection coll1)：差集：从当前集合中移除coll1中所有的元素(移除共有的元素)</span></span><br><span class="line">        Collection coll1 = Arrays.asList(<span class="number">123</span>,<span class="number">456</span>);</span><br><span class="line">        coll.removeAll(coll1);</span><br><span class="line">        System.out.println(coll); <span class="comment">// [AA]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.retainAll():交集：获取当前集合和coll1集合的交际，并修改当前集合</span></span><br><span class="line">        coll.retainAll(coll1);</span><br><span class="line">        System.out.println(coll); <span class="comment">//[]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.equals(Objcet obj):要想返回True，需要当前集合和形参集合元素都相同</span></span><br><span class="line">        System.out.println(coll.equals(coll1)); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        coll.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;BB&quot;</span>);</span><br><span class="line">        coll.add(<span class="number">123</span>); <span class="comment">// 自动装箱</span></span><br><span class="line">        coll.add(<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.hashCode():返回当前对象的哈希值</span></span><br><span class="line">        System.out.println(coll.hashCode());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.集合----&gt;数组：toArray()</span></span><br><span class="line">        Object[] arr = coll.toArray(); <span class="comment">// 数组arr</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="集合元素的遍历操作"><a href="#集合元素的遍历操作" class="headerlink" title="集合元素的遍历操作"></a>集合元素的遍历操作</h4><ul>
<li>使用迭代器Iterator接口<ul>
<li>内部的方法：hasNext()和next()</li>
<li>集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认指针都在集合的第一个元素之间</li>
<li>内部定义了remove()，可以在遍历的时候，删除集合中的元素，</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    coll.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">    coll.add(<span class="string">&quot;BB&quot;</span>);</span><br><span class="line">    coll.add(<span class="number">123</span>);</span><br><span class="line">    coll.add(<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//iterator()：返回迭代器Iterator接口的实例，用于遍历集合元素</span></span><br><span class="line">    Iterator iterator = coll.iterator();</span><br><span class="line">    <span class="comment">// 遍历集合中所有的元素</span></span><br><span class="line">    <span class="comment">// hasNext()：判断是否还有下一个元素</span></span><br><span class="line">    <span class="comment">// next()：指针下移，将下移以后集合位置上的元素返回</span></span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        Object next = iterator.next();</span><br><span class="line">        <span class="comment">// 删除集合中&quot;AA&quot;的元素</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;AA&quot;</span>.equals(next))&#123;</span><br><span class="line">            iterator.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>foreach（增强for循环）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jdk5.0新增了foreach循环，用来遍历集合、数组</span></span><br><span class="line"><span class="comment">// for(集合中元素的类型 局部变量 ：集合对象)</span></span><br><span class="line"><span class="comment">// 内部仍然调用的迭代器</span></span><br><span class="line"><span class="keyword">for</span>(Object obj : coll)&#123;</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h4><h5 id="List接口中常用方法"><a href="#List接口中常用方法" class="headerlink" title="List接口中常用方法"></a>List接口中常用方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, Object ele)</span> <span class="comment">// 在index位置插入ele元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection eles)</span> <span class="comment">// 从index位置开始将eles中的所有元素添加进来</span></span></span><br><span class="line"><span class="function">Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> <span class="comment">//获取指定index位置的元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object obj)</span> <span class="comment">// 返回obj在集合中首次出现的位置</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object obj)</span> <span class="comment">// 返回obj在当前集合中末次出现的位置</span></span></span><br><span class="line"><span class="function">Object <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> <span class="comment">// 移除指定index位置的元素，并返回此元素</span></span></span><br><span class="line"><span class="function">Object <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, Object ele)</span> <span class="comment">// 设置指定index位置的元素为ele</span></span></span><br><span class="line"><span class="function">List <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> <span class="comment">// 返回从fromIndex到toIndex位置左闭右开的子集合</span></span></span><br></pre></td></tr></table></figure>

<h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h5><p><strong>源码分析</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jdk 7情况下：类似于单例的饿汉式</span></span><br><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList(); <span class="comment">// 底层创建了长度为10的Object[]数组elementData</span></span><br><span class="line">list.add(<span class="number">123</span>); <span class="comment">// elementData[0] = new Integer(123);</span></span><br><span class="line">...</span><br><span class="line">list.add(<span class="number">1</span>);<span class="comment">// 如果此次添加导致底层elementData数组容量不够，则扩容，默认情况下扩容为原来的1.5倍</span></span><br><span class="line"><span class="comment">// 同时将原来的数组复制到新的数组中，所以使用带参的构造器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// jdk 8源码变化：类似于单例的懒汉式，延迟了数组的创建，节省内存</span></span><br><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList(); <span class="comment">// 底层Object[]数组elementData初始化为&#123;&#125;，并没有创建长度为10的数组</span></span><br><span class="line">list.add(<span class="number">123</span>); <span class="comment">// 第一次调用add()时，底层才创建了长度为10的数组，将123添加到elementData数组中</span></span><br><span class="line">...</span><br><span class="line">list.add(<span class="number">1</span>);<span class="comment">// 和jdk 7中相同</span></span><br></pre></td></tr></table></figure>

<h5 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h5><p><strong>源码分析</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LinkedList list = <span class="keyword">new</span> LinkedList(); <span class="comment">//内部声明了Node类型的first和last属性，默认值为null</span></span><br><span class="line">list.add(<span class="number">123</span>); <span class="comment">// 将123封装到Node中，创建了Node对象（prev + item + next）双向链表</span></span><br></pre></td></tr></table></figure>



<h4 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h4><p><em>存储无序的、不可重复的数据</em></p>
<p><strong>要求</strong></p>
<ul>
<li>向Set中添加的数据，其所在的类一定要重写hashCode()和equals()</li>
<li>重写的hashCode()和equals()尽可能的保持一致性：相同的对象必须有相等的哈希值</li>
</ul>
<p><strong>特点：</strong>以HashSet为例（数组 + 链表）（<strong>前提：JDK 7</strong>）</p>
<ul>
<li>无序性：不等于随机性，存储的数据在底层数据中并非按照数组索引的顺序添加的，而是根据数据的哈希值确定的</li>
<li>不可重复性：保证添加的元素按照equals()判断时，不能返回true，相同的元素只能添加一个</li>
<li>添加元素过程（以HashSet为例）：我们向HashSet中添加元素a，首先调用元素a所在类的hashCode()，计算元素a的哈希值，此哈希值接着通过某种算法计算出在HashSet底层数组中的存放位置（即索引位置），判断数组此位置上是否已经有元素：<ul>
<li>如果此位置上没有其他元素，则元素a添加成功</li>
<li>如果此位置上有其他元素b（或以链表形式存在的多个元素），则比较元素a和元素b的hash值：<ul>
<li>如果hash值不相同，则元素a添加成功，以链表的方式存储（七上八下）</li>
<li>如果hash值相同，继而需要调用元素a所在类的equals()方法，如果返回true，元素a添加失败，返回false，添加成功（以链表的方式存储）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h5><p>见上~</p>
<h5 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h5><p>作为HashSet的子类，在添加数据的同时，每个数据还维护了两个引用，记录此数据的前一个和后一个数据</p>
<p>对于频繁遍历操作，LinkedHashSet效率高于HashSet </p>
<h5 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h5><ul>
<li>向TreeSet中添加的数据，要求是相同类的对象</li>
<li>两种排序的方式：自然排序和定制排序</li>
<li>自然排序中，比较两个对象是否相同的标准为：compareTo()返回0，不再是equals()</li>
<li>定制排序中，比较两个对象是否相同的标准为：compare返回0，不再是equals()</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person类---&gt;实现Comparable接口、重写toString()和compareTo()</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">            Person u = (Person) o;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name.compareTo(u.name);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;输入的数据类型不匹配&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在TreeSet中遍历是按对象的属性排列的，用自然排序或定制排序</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Comparator com = <span class="keyword">new</span> Comparator() &#123;</span><br><span class="line">        <span class="comment">// 按照年龄从小到大排列</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> <span class="keyword">throws</span> RuntimeException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o1 <span class="keyword">instanceof</span> Person &amp;&amp; o2 <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">                Person u1 = (Person) o1;</span><br><span class="line">                Person u2 = (Person) o2;</span><br><span class="line">                <span class="keyword">return</span> Integer.compare(u1.age, u2.age);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;输入的数据类型不匹配&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    TreeSet treeSet = <span class="keyword">new</span> TreeSet(com);<span class="comment">// 有参数定制排序，没参数自然排序</span></span><br><span class="line"></span><br><span class="line">    treeSet.add(<span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>, <span class="number">12</span>));</span><br><span class="line">    treeSet.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jack&quot;</span>, <span class="number">14</span>));</span><br><span class="line">    treeSet.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jerry&quot;</span>, <span class="number">24</span>));</span><br><span class="line">    treeSet.add(<span class="keyword">new</span> Person(<span class="string">&quot;Sam&quot;</span>, <span class="number">43</span>));</span><br><span class="line"></span><br><span class="line">    Iterator iterator = treeSet.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h3><h4 id="Map结构"><a href="#Map结构" class="headerlink" title="Map结构"></a>Map结构</h4><ul>
<li>Map中的key：无序的、不可重复的，使用Set存储所有的key</li>
<li>Map中的value：无序的、可重复的，使用Collection存储所有的value</li>
<li>一个键值对：key-value构成了一个Entry（条目）对象</li>
<li>Map中的Entry：无序的、不可重复的，使用Set存储所有的entry</li>
</ul>
<h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><p><strong>JDK 7</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">HashMap map = <span class="keyword">new</span> HashMap();</span><br><span class="line"><span class="comment">// 在实例化以后，底层创建了长度为16的一维数组Entry[] table</span></span><br><span class="line"><span class="comment">// ....可能已经执行过多次put....</span></span><br><span class="line">map.put(key1, value1);</span><br><span class="line"><span class="comment">/** 调用key1所在类的hashCode()计算key1的哈希值，经过某种算法计算以后，得到在Entry数组中的存放位置</span></span><br><span class="line"><span class="comment">*	如果此位置上的元素为空，此时的key1-value1添加成功</span></span><br><span class="line"><span class="comment">*	如果 此位置上的元素不为空，（意味着此位置上存在一个或多个数据（以链表的形式存在）），比较key1和已经存在的一个或多个数据的哈希值</span></span><br><span class="line"><span class="comment">*		如果key1的哈希值与已经存在的数据的哈希值都不相同，此时key1-value1添加成功（链表形式）</span></span><br><span class="line"><span class="comment">*		如果key1的哈希值与已经存在的某一个数据(key2-value2)的哈希值相同，继续比较，调用key1所在类的equals(key2)</span></span><br><span class="line"><span class="comment">*			如果equals()返回false：此时key1-value1添加成功（链表形式）</span></span><br><span class="line"><span class="comment">*			如果equals()返回true：使用value1替换value2</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*	扩容问题：扩容为原来容量的2倍，并将原有的数据复制过来</span></span><br><span class="line"><span class="comment">*			[当超出临界值(且要存放的位置非空)时，会扩容]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>JDK 8</strong></p>
<p><em>相较于JDK7的不同</em></p>
<ul>
<li>new HashMap()：底层没有创建一个长度为16的数组</li>
<li>JDK 8底层的数组是：Node[]，而不是Entry[]</li>
<li>首次调用put()时，底层创建长度为16的数组</li>
<li>JDK 7底层结构只有数组+链表；JDK 8中底层结构：数组+链表+红黑树<ul>
<li>当数组的某一个索引位置上的元素以链表形式存在的数据个数 <strong>&gt; 8</strong> 且当前数组的长度 **&gt; 64 **时，此时此索引位置上的所有数据改为使用红黑树存储</li>
</ul>
</li>
<li>源码中<strong>重要常量</strong><ul>
<li>DEFAULT_INITIAL_CAPACITY：HashMap的默认容量：16</li>
<li>DEFAULT_LOAD_FACTOR：HashMap的默认加载因子：0.75</li>
<li>threshold：扩容的临界值 = 容量 * 加载因子：16 * 0.75 = 12</li>
<li>TREEIFY_THRESHOLD：链表长度大于给默认值，转化为红黑树：8</li>
<li>MIN_TREEIFY_CAPACITY：Node被树化时最小的hash表容量：64</li>
</ul>
</li>
</ul>
<h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 就多了一个前后的指针</span></span><br><span class="line">Entry &lt;K, V&gt; before, after; <span class="comment">// 能够记录添加的元素的先后顺序</span></span><br></pre></td></tr></table></figure>



<h4 id="Map中常用方法"><a href="#Map中常用方法" class="headerlink" title="Map中常用方法"></a>Map中常用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加、删除、修改操作：</span></span><br><span class="line"><span class="function">Object <span class="title">put</span><span class="params">(Object key,Object value)</span><span class="comment">// 将指定key-value添加到(或修改)当前map对象中</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map m)</span><span class="comment">// 将m中的所有key-value对存放到当前map中</span></span></span><br><span class="line"><span class="function">Object <span class="title">remove</span><span class="params">(Object key)</span><span class="comment">// 移除指定key的key-value对，并返回value</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span><span class="comment">// 清空当前map中的所有数据，与map=null不同</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// 元素查询的操作：</span></span></span><br><span class="line"><span class="function">Object <span class="title">get</span><span class="params">(Object key)</span><span class="comment">// 获取指定key对应的value</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span><span class="comment">// 是否包含指定的key</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span><span class="comment">// 是否包含指定的value</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span><span class="comment">// 返回map中key-value对的个数</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span><span class="comment">// 判断当前map是否为空</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span><span class="comment">// 判断当前map和参数对象obj是否相等</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// 元视图操作的方法：</span></span></span><br><span class="line"><span class="function">Set <span class="title">keySet</span><span class="params">()</span><span class="comment">// 返回所有key构成的Set集合</span></span></span><br><span class="line"><span class="function">Collection <span class="title">values</span><span class="params">()</span><span class="comment">// 返回所有value构成的Collection集合</span></span></span><br><span class="line"><span class="function">Set <span class="title">entrySet</span><span class="params">()</span><span class="comment">// 返回所有key-value对构成的Set集合，集合中的元素都是Map.entry(强转后有getKey()和getValue())</span></span></span><br></pre></td></tr></table></figure>



<h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><p><em>跟TreeSet极其类似</em></p>
<ul>
<li>向TreeMap中添加key-value，要求key必须时由同一个类创建的对象</li>
<li>有自然排序和定制排序</li>
</ul>
<h3 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h3><p><em>Collections是一个操作Set、List和Map等集合的工具类</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 排序操作：（均为static方法）</span></span><br><span class="line">reverse(List)<span class="comment">// 反转 List 中元素的顺序</span></span><br><span class="line">shuffle(List)<span class="comment">// 对 List 集合元素进行随机排序</span></span><br><span class="line">sort(List)<span class="comment">// 根据元素的自然顺序对指定 List 集合元素按升序排序</span></span><br><span class="line">sort(List，Comparator)<span class="comment">// 根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</span></span><br><span class="line">swap(List，<span class="keyword">int</span>， <span class="keyword">int</span>)<span class="comment">// 将指定 list 集合中的 i 处元素和 j 处元素进行交换</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 查找、替换</span></span><br><span class="line"><span class="function">Object <span class="title">max</span><span class="params">(Collection)</span><span class="comment">// 根据元素的自然顺序，返回给定集合中的最大元素</span></span></span><br><span class="line"><span class="function">Object <span class="title">max</span><span class="params">(Collection，Comparator)</span><span class="comment">// 根据 Comparator 指定的顺序，返回给定集合中的最大元素</span></span></span><br><span class="line"><span class="function">Object <span class="title">min</span><span class="params">(Collection)</span></span></span><br><span class="line"><span class="function">Object <span class="title">min</span><span class="params">(Collection，Comparator)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">frequency</span><span class="params">(Collection，Object)</span><span class="comment">// 返回指定集合中指定元素的出现次数</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(List dest,List src)</span><span class="comment">// 将src中的内容复制到dest中 </span></span></span><br><span class="line"><span class="function">    <span class="comment">//---- &gt; 标准使用方法：List dest = Arrays.asList(new Object[list.size()]); Collections.copy(dest, list);</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">replaceAll</span><span class="params">(List list，Object oldVal，Object newVal)</span><span class="comment">// 使用新值替换List 对象的所有旧值</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// Collections类张提供了多个synchronizedXxx()，该方法可使指定集合包装成线程同步的集合，来解决多线程并发访问集合时的线程安全问题</span></span></span><br><span class="line"><span class="function">List list1 </span>= Collections.synchronizedList(list); <span class="comment">// 返回的list1j</span></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p><em>JDK 5新增的特性</em></p>
<h3 id="集合中泛型"><a href="#集合中泛型" class="headerlink" title="集合中泛型"></a>集合中泛型</h3><ul>
<li>集合接口或集合类在JDK 5时都修改为带泛型的结构</li>
<li>在实例化集合类时，可以指明具体的泛型类型</li>
<li>指明完以后，在集合类或接口中凡是定义类或接口时，内部结构用到泛型的位置，都指定为实例化时泛型的类型，比如：add(E e)—&gt;add(Integer e)</li>
<li>泛型的类型必须是类，不能是基本数据类型，需要用到基本数据类型的位置，拿包装类替换</li>
<li>如果实例化时，没有指明泛型的类型，默认类型为java.lang.Object类型</li>
</ul>
<h3 id="自定义泛型"><a href="#自定义泛型" class="headerlink" title="自定义泛型"></a>自定义泛型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义的泛型类</span></span><br><span class="line"><span class="comment">// 子类继承有泛型的父类时，可以继承父类指定的类型，也可以继承父类未指定的泛型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span>&lt;<span class="title">T</span>&gt; </span>&#123; </span><br><span class="line">    String orderName;</span><br><span class="line">    <span class="keyword">int</span> orderId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类的内部结构可以使用类的泛型</span></span><br><span class="line">    T orderT;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Order</span><span class="params">(String orderName, <span class="keyword">int</span> orderId, T orderT)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.orderName = orderName;</span><br><span class="line">        <span class="keyword">this</span>.orderId = orderId;</span><br><span class="line">        <span class="keyword">this</span>.orderT = orderT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如下的方法不是泛型方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getOrderT</span><span class="params">()</span></span>&#123; <span class="comment">// 不能静态，T没确定</span></span><br><span class="line">        <span class="keyword">return</span> orderT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrderT</span><span class="params">(T orderT)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.orderT = orderT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 泛型方法：在方法中出现了泛型的结构，泛型参数与类的泛型参数没有任何关系，也就是说，泛型方法所属的类不一定是泛型类</span></span><br><span class="line">    <span class="comment">// 在返回值后面加上标识泛型的标志</span></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">copyFromArrayToList</span><span class="params">(E[] arr)</span></span>&#123; <span class="comment">// 可以静态，创建完对象才能用，此时E已确定</span></span><br><span class="line">        ArrayList&lt;E&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// 前面加泛型的标志，后面可以不加了</span></span><br><span class="line">        <span class="keyword">for</span> (E e : arr)&#123;</span><br><span class="line">            list.add(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><h4 id="泛型在继承方面的体现"><a href="#泛型在继承方面的体现" class="headerlink" title="泛型在继承方面的体现"></a>泛型在继承方面的体现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 类A是类B的父类，但G&lt;A&gt;和G&lt;B&gt;二者不具备子父类的关系，是并列关系</span><br><span class="line">- 类A是类B的父类，A&lt;G&gt;是B&lt;G&gt;的父类</span><br></pre></td></tr></table></figure>



<h4 id="通配符的使用"><a href="#通配符的使用" class="headerlink" title="通配符的使用"></a>通配符的使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- 类A是类B的父类，但G&lt;A&gt;和G&lt;B&gt;没有关系，二者共同的父类是：G&lt;?&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Object&gt; list1 = <span class="keyword">null</span>;</span><br><span class="line">List&lt;String&gt; list2 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(List&lt;?&gt; list)</span></span>&#123;</span><br><span class="line">    Iterator&lt;?&gt; iterator = list.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        Object obj = iterator.next();</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 添加（写入）：对于List&lt;?&gt;```ja就不能向其内部添加数据，除了添加<span class="keyword">null</span>以外</span><br><span class="line">- 获取（读取）：允许读取数据，读取的顺序类型为Object</span><br></pre></td></tr></table></figure>

<p><strong>有限制条件的通配符的使用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- ? extends A：G&lt;? extends A&gt; 可以作为G&lt;A&gt;和G&lt;B&gt;的父类的，其中B是A的子类</span><br><span class="line">- ? <span class="keyword">super</span> A：G&lt;? <span class="keyword">super</span> A&gt; 可以作为G&lt;A&gt;和G&lt;B&gt;的父类的，其中B是A的父类</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><h3 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h3><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ul>
<li>File类的一个对象，代表一个文件或一个文件目录（俗称：文件夹）</li>
<li>File类声明在java.io包下</li>
<li>File类中涉及到关于文件或文件目录的各种操作的方法，并未涉及到写入或读取文件内容的操作</li>
<li>后续File类的对象，常会作为参数传递给流的构造器中，指明具体文件的“地址”</li>
</ul>
<p><strong>创建File类实例</strong></p>
<ul>
<li>File(String filePath)</li>
<li>File(String parentPath, String childPath)</li>
<li>File(File parentFile, childPath)</li>
</ul>
<p><strong>路径分隔符</strong></p>
<p>windows：\\    unix：/</p>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File类的获取功能</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getAbsolutePath</span><span class="params">()</span><span class="comment">// 获取绝对路径</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPath</span><span class="params">()</span><span class="comment">// 获取路径</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span><span class="comment">// 获取名称</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getParent</span><span class="params">()</span><span class="comment">// 获取上层文件目录路径。若无，返回null</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">length</span><span class="params">()</span><span class="comment">// 获取文件长度（即：字节数）。不能获取目录的长度。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">lastModified</span><span class="params">()</span><span class="comment">// 获取最后一次的修改时间，毫秒值</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String[] <span class="title">list</span><span class="params">()</span><span class="comment">// 获取指定目录下的所有文件或者文件目录的名称数组</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> File[] <span class="title">listFiles</span><span class="params">()</span><span class="comment">// 获取指定目录下的所有文件或者文件目录的File数组</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// File类的重命名功能</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">renameTo</span><span class="params">(File dest)</span><span class="comment">// 把文件重命名为指定的文件路径----&gt;移动+改名</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> renameTo </span>= file1.renameTo(file2);<span class="comment">// 要求file1是真实存在的，file2不能存在</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// File类的判断功能</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDirectory</span><span class="params">()</span><span class="comment">// 判断是否是文件目录</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFile</span><span class="params">()</span><span class="comment">// 判断是否是文件</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exists</span><span class="params">()</span><span class="comment">// 判断是否存在</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canRead</span><span class="params">()</span><span class="comment">// 判断是否可读</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canWrite</span><span class="params">()</span><span class="comment">// 判断是否可写</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHidden</span><span class="params">()</span><span class="comment">// 判断是否隐藏</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// File类中创建硬盘中对应的文件或文件目录</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">createNewFile</span><span class="params">()</span><span class="comment">// 创建文件。若文件存在，则不创建，返回false</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">mkdir</span><span class="params">()</span><span class="comment">// 创建文件目录。如果此文件目录存在，就不创建了，如果此文件目录的上层目录不存在，也不创建。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">mkdirs</span><span class="params">()</span><span class="comment">// 创建文件目录。如果上层文件目录不存在，一并创建</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">()</span><span class="comment">// 删除文件或者文件夹</span></span></span><br><span class="line"><span class="function"><span class="comment">// 注意：Java中的删除不走回收站</span></span></span><br></pre></td></tr></table></figure>


    </div>
    <div>
      
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>

      
    </div>
	
	
    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/03/29/Python%E8%A1%A5%E7%A5%A8/" rel="prev" title="Python补票">
      <i class="fa fa-chevron-left"></i> Python补票
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>


      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="nav-number">1.1.</span> <span class="nav-text">基础概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%A3%B0%E6%98%8E%E5%91%A8%E6%9C%9F"><span class="nav-number">1.1.1.</span> <span class="nav-text">线程的声明周期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Thread%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B8%B8%E9%87%8F%E5%92%8C%E6%96%B9%E6%B3%95"><span class="nav-number">1.1.2.</span> <span class="nav-text">Thread中常用的常量和方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6"><span class="nav-number">1.1.3.</span> <span class="nav-text">同步机制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.2.</span> <span class="nav-text">创建多线程的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E7%BB%A7%E6%89%BFThread%E7%B1%BB"><span class="nav-number">1.2.1.</span> <span class="nav-text">1. 继承Thread类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.2.2.</span> <span class="nav-text">2. 实现Runnable接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%AE%9E%E7%8E%B0Callable%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.2.3.</span> <span class="nav-text">3. 实现Callable接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">1.2.4.</span> <span class="nav-text">4. 使用线程池</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="nav-number">2.</span> <span class="nav-text">Java常用类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#String"><span class="nav-number">2.1.</span> <span class="nav-text">String</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#StringBuffer%E5%92%8CStringBuilder"><span class="nav-number">2.2.</span> <span class="nav-text">StringBuffer和StringBuilder</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E5%85%B3Date%E7%9A%84%E7%B1%BB"><span class="nav-number">2.3.</span> <span class="nav-text">有关Date的类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JDK1-8%E4%B9%8B%E5%89%8D"><span class="nav-number">2.3.1.</span> <span class="nav-text">JDK1.8之前</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JDK1-8%E6%96%B0%E5%A2%9E"><span class="nav-number">2.3.2.</span> <span class="nav-text">JDK1.8新增</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Comparable%EF%BC%88%E8%87%AA%E7%84%B6%E6%8E%92%E5%BA%8F%EF%BC%89"><span class="nav-number">2.4.</span> <span class="nav-text">Comparable（自然排序）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Comparator%EF%BC%88%E5%AE%9A%E5%88%B6%E6%8E%92%E5%BA%8F%EF%BC%89"><span class="nav-number">2.5.</span> <span class="nav-text">Comparator（定制排序）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="nav-number">3.</span> <span class="nav-text">枚举类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="nav-number">3.1.</span> <span class="nav-text">定义枚举类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Enum%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">3.2.</span> <span class="nav-text">Enum类的常用方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8enum%E5%AE%9A%E4%B9%89%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="nav-number">3.3.</span> <span class="nav-text">使用enum定义枚举类实现接口</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3"><span class="nav-number">4.</span> <span class="nav-text">注解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3%E3%80%81%E5%8F%AF%E9%87%8D%E5%A4%8D%E6%B3%A8%E8%A7%A3"><span class="nav-number">4.1.</span> <span class="nav-text">类型注解、可重复注解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%86%E5%90%88"><span class="nav-number">5.</span> <span class="nav-text">集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">5.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%86%E6%9E%B6"><span class="nav-number">5.2.</span> <span class="nav-text">框架</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Collection%E6%8E%A5%E5%8F%A3"><span class="nav-number">5.3.</span> <span class="nav-text">Collection接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Collection%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E6%A0%91"><span class="nav-number">5.3.1.</span> <span class="nav-text">Collection接口继承树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Collection%E6%8E%A5%E5%8F%A3%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">5.3.2.</span> <span class="nav-text">Collection接口中常用方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E5%85%83%E7%B4%A0%E7%9A%84%E9%81%8D%E5%8E%86%E6%93%8D%E4%BD%9C"><span class="nav-number">5.3.3.</span> <span class="nav-text">集合元素的遍历操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#List%E6%8E%A5%E5%8F%A3"><span class="nav-number">5.3.4.</span> <span class="nav-text">List接口</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#List%E6%8E%A5%E5%8F%A3%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">5.3.4.1.</span> <span class="nav-text">List接口中常用方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ArrayList"><span class="nav-number">5.3.4.2.</span> <span class="nav-text">ArrayList</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#LinkedList"><span class="nav-number">5.3.4.3.</span> <span class="nav-text">LinkedList</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Set%E6%8E%A5%E5%8F%A3"><span class="nav-number">5.3.5.</span> <span class="nav-text">Set接口</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#HashSet"><span class="nav-number">5.3.5.1.</span> <span class="nav-text">HashSet</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#LinkedHashSet"><span class="nav-number">5.3.5.2.</span> <span class="nav-text">LinkedHashSet</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TreeSet"><span class="nav-number">5.3.5.3.</span> <span class="nav-text">TreeSet</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Map%E6%8E%A5%E5%8F%A3"><span class="nav-number">5.4.</span> <span class="nav-text">Map接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Map%E7%BB%93%E6%9E%84"><span class="nav-number">5.4.1.</span> <span class="nav-text">Map结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap"><span class="nav-number">5.4.2.</span> <span class="nav-text">HashMap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LinkedHashMap"><span class="nav-number">5.4.3.</span> <span class="nav-text">LinkedHashMap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Map%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">5.4.4.</span> <span class="nav-text">Map中常用方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TreeMap"><span class="nav-number">5.4.5.</span> <span class="nav-text">TreeMap</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Collections%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="nav-number">5.5.</span> <span class="nav-text">Collections工具类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B"><span class="nav-number">6.</span> <span class="nav-text">泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E4%B8%AD%E6%B3%9B%E5%9E%8B"><span class="nav-number">6.1.</span> <span class="nav-text">集合中泛型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B"><span class="nav-number">6.2.</span> <span class="nav-text">自定义泛型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A5%E5%85%85"><span class="nav-number">6.3.</span> <span class="nav-text">补充</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E5%9C%A8%E7%BB%A7%E6%89%BF%E6%96%B9%E9%9D%A2%E7%9A%84%E4%BD%93%E7%8E%B0"><span class="nav-number">6.3.1.</span> <span class="nav-text">泛型在继承方面的体现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E9%85%8D%E7%AC%A6%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">6.3.2.</span> <span class="nav-text">通配符的使用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IO%E6%B5%81"><span class="nav-number">7.</span> <span class="nav-text">IO流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#File%E7%B1%BB"><span class="nav-number">7.1.</span> <span class="nav-text">File类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E"><span class="nav-number">7.1.1.</span> <span class="nav-text">说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">7.1.2.</span> <span class="nav-text">常用方法</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="KK"
      src="/images/main.jpg">
  <p class="site-author-name" itemprop="name">KK</p>
  <div class="site-description" itemprop="description">记录生活中的点点滴滴~</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>


<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1811921555&auto=1&height=66"></iframe>



    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">KK</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">56k</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div><script color="0,0,255" opacity="0.5" zIndex="-1" count="99" src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js"></script>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body>
</html>

<a target="_blank" rel="noopener" href="https://github.com/52Hz-Kun" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/click.js"></script>