<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/tiger32_32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/tiger16_16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":"ture","show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="多线程基础概念程序：是为了完成特定任务，用某种语言编写的一组指令的集合，即指一段静态的代码，静态对象 进程：是程序的一次执行过程，或是正在运行的一个程序，是一个动态的过程，有它自身的产生、存在和消亡的过程——生命周期 线程：进程可进一步细化为线程，是一个程序内部的一条执行路径  线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器(pc) 一个进程中的多个线程共享相同的内存单元&#x2F;内存地">
<meta property="og:type" content="article">
<meta property="og:title" content="Java高级">
<meta property="og:url" content="http://example.com/2021/04/14/Java%E9%AB%98%E7%BA%A7/index.html">
<meta property="og:site_name" content="KKのblog">
<meta property="og:description" content="多线程基础概念程序：是为了完成特定任务，用某种语言编写的一组指令的集合，即指一段静态的代码，静态对象 进程：是程序的一次执行过程，或是正在运行的一个程序，是一个动态的过程，有它自身的产生、存在和消亡的过程——生命周期 线程：进程可进一步细化为线程，是一个程序内部的一条执行路径  线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器(pc) 一个进程中的多个线程共享相同的内存单元&#x2F;内存地">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wx1.sinaimg.cn/large/006GctFNgy1gpou3sn18dj30wr0dxtds.jpg">
<meta property="og:image" content="https://wx3.sinaimg.cn/large/006GctFNgy1gpp0xxqj5zj30xq0i6n8j.jpg">
<meta property="article:published_time" content="2021-04-14T03:48:35.000Z">
<meta property="article:modified_time" content="2021-04-21T07:50:24.726Z">
<meta property="article:author" content="KK">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wx1.sinaimg.cn/large/006GctFNgy1gpou3sn18dj30wr0dxtds.jpg">

<link rel="canonical" href="http://example.com/2021/04/14/Java%E9%AB%98%E7%BA%A7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java高级 | KKのblog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">KKのblog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签<span class="badge">1</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类<span class="badge">1</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档<span class="badge">5</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/14/Java%E9%AB%98%E7%BA%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/main.jpg">
      <meta itemprop="name" content="KK">
      <meta itemprop="description" content="记录生活中的点点滴滴~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KKのblog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java高级
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-14 11:48:35" itemprop="dateCreated datePublished" datetime="2021-04-14T11:48:35+08:00">2021-04-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-21 15:50:24" itemprop="dateModified" datetime="2021-04-21T15:50:24+08:00">2021-04-21</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>16k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <hr>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><p><strong>程序：</strong>是为了完成特定任务，用某种语言编写的一组指令的集合，即指一段<strong>静态的代码</strong>，静态对象</p>
<p><strong>进程：</strong>是程序的一次执行过程，或是正在运行的一个程序，是一个<strong>动态的过程</strong>，有它自身的产生、存在和消亡的过程——生命周期</p>
<p><strong>线程：</strong>进程可进一步细化为线程，是一个程序内部的一条执行路径</p>
<ul>
<li>线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器(pc)</li>
<li>一个进程中的多个线程共享相同的内存单元/内存地址空间—&gt;从同一堆中分配对象，可以访问相同的变量和对象（静态的）</li>
</ul>
<p><strong>并行：</strong>多个CPU同时执行多个任务</p>
<p><strong>并发：</strong>一个CPU（采用时间片）同时执行多个任务</p>
<span id="more"></span>

<h4 id="线程的声明周期"><a href="#线程的声明周期" class="headerlink" title="线程的声明周期"></a>线程的声明周期</h4><img src="https://wx1.sinaimg.cn/large/006GctFNgy1gpou3sn18dj30wr0dxtds.jpg" alt="线程的声明周期" style="zoom:67%;" />

<h4 id="Thread中常用的常量和方法"><a href="#Thread中常用的常量和方法" class="headerlink" title="Thread中常用的常量和方法"></a>Thread中常用的常量和方法</h4><p><strong>常用方法</strong></p>
<ol>
<li>start()：启动当前线程，调用当前线程的run()</li>
<li>run()：通常需要会重写Thread类中的此方法，将创建的线程要执行的操作声明再此方法中</li>
<li>currentThread()：静态方法，返回执行当前代码的线程</li>
<li>getName()：获取当前线程的名字</li>
<li>setName()：设置当前线程的名字</li>
<li>yield()：释放当前cpu的执行权（下一时刻cpu执行哪个线程随机）</li>
<li>join()：再线程a中调用线程b的join()，此时线程a就进入阻塞状态，直到线程b完全执行完以后，线程a才结束阻塞状态</li>
<li>stop()：<strong>已过时。</strong>当执行此方法时，强制结束当前线程</li>
<li>sleep(long millitime)：让当前线程“睡眠”指定的多少毫秒，在指定的时间内，当前线程时阻塞状态</li>
<li>isAlive()：判断当前线程是否存活</li>
</ol>
<p><strong>优先级</strong></p>
<ol>
<li><ul>
<li>MAX_PRIORITY:10</li>
<li>MIN_PRIORITY:1</li>
<li>NORM_PRIORITY:5 —&gt; 默认的优先级</li>
</ul>
</li>
<li><ul>
<li>getPriority()：获取线程的优先级</li>
<li>setPriority(int p)：设置线程的优先级</li>
<li>高优先级的线程要抢占低优先级线程cpu的执行权，但是只是从概率上来说，高优先级的线程高概率的情况下被执行，并不意味着只有当高优先级的线程执行完以后，低优先级的线程才执行</li>
</ul>
</li>
</ol>
<h4 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h4><p><em>Java中使用同步机制，来解决线程的安全问题</em></p>
<p><strong>1. 同步代码块</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 说明：1.操作共享数据的代码，即为需要被同步的代码 ---&gt;不能包含多了或少了</span></span><br><span class="line"><span class="comment"> *      2.共享数据：多个线程共同操作的变量，如买票的总票数</span></span><br><span class="line"><span class="comment"> *      3.同步监视器，俗称“锁”，任何一个类的对象，都可以充当锁</span></span><br><span class="line"><span class="comment"> *      要求：多个线程必须要共用同一把锁(this，当期类等等，看具体情况)</span></span><br><span class="line"><span class="comment"> * 		</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">    <span class="comment">// 需要被同步的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优缺点</p>
<ul>
<li>同步的方式，解决了线程的安全问题</li>
<li>但操作同步代码的时，只能有一个线程参与，其他线程等待，相当于是一个单线程的过程，效率低</li>
</ul>
<p><strong>2. 同步方法</strong></p>
<p>如果操作共享数据的代码完全的声明在一个方法中，可以将此方法声明为同步的</p>
<ol>
<li>同步的方法仍然涉及到同步监视器，只是不需要我们显式的申明</li>
<li>非静态的同步方法，同步监视器是：this；静态的同步方法，同步监视器是其本身</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>



<p><strong>3. Lock锁（JDK5.0新增）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">//run()里面的执行的操作</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// 调用锁定的方法：lock()</span></span><br><span class="line">    lock.lock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多线程中需要同步的代码</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">// 调用解锁的方法：unlock</span></span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>死锁</strong></p>
<ul>
<li>不同的线程分别占用对方所需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁（看双方握住的同步监视器是否交叉啥的）</li>
<li>出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处在阻塞状态，无法继续</li>
<li>使用同步时，需要避免出现死锁</li>
</ul>
<p><strong>线程通信</strong></p>
<ul>
<li>wait()：一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器</li>
<li>notify()：一点执行此方法，就会唤醒被wait的一个线程，如果有多个线程被wait，就唤醒优先级高的线程</li>
<li>notifyAll()：一旦执行此方法，就会唤醒所有被wait的线程</li>
<li>说明<ul>
<li>以上三个方法必须使用在同步代码块或同步方法中</li>
<li>以上三个方法的调用者必须是同步代码块或同步方法中的同步监视器，否则异常</li>
<li>都是定义在Object类中的方法</li>
</ul>
</li>
</ul>
<h3 id="创建多线程的方法"><a href="#创建多线程的方法" class="headerlink" title="创建多线程的方法"></a>创建多线程的方法</h3><h4 id="1-继承Thread类"><a href="#1-继承Thread类" class="headerlink" title="1. 继承Thread类"></a>1. 继承Thread类</h4><ol>
<li>创建一个继承于Thread类的子类</li>
<li>重写Thread类的run()—&gt;将此线程执行的操作声明在run()中</li>
<li>创建Thread类的子类的对象</li>
<li>通过此对象调用start()</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式1：继承与Thread类</span></span><br><span class="line">    <span class="comment">// 遍历100以内的所有偶数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        </span><br><span class="line">        MyThread t1 = <span class="keyword">new</span> MyThread();   </span><br><span class="line">        <span class="comment">// 启动当前线程，调用当前线程的run()</span></span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="comment">// 再启动一个线程，遍历100以内的偶数，，需要再创建一个线程的对象</span></span><br><span class="line">        MyThread t2 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        t2.start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如下操作仍然是在main线程中执行的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(i + <span class="string">&quot;main&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="comment">// 重写Thread类的run()---&gt;将此线程执行的操作声明在run()中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-实现Runnable接口"><a href="#2-实现Runnable接口" class="headerlink" title="2. 实现Runnable接口"></a>2. 实现Runnable接口</h4><ol>
<li>创建一个实现了Runnable接口的类</li>
<li>实现类去实现Runnable中的抽象方法</li>
<li>创建实现类的对象</li>
<li>将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</li>
<li>通过Thread类的对象调用start()</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MThread mThread = <span class="keyword">new</span> MThread();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(mThread);</span><br><span class="line">        <span class="comment">// 1.启动线程 2.调用当前线程的run()---&gt;调用了Runnable类型的的target的run方法</span></span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开发当中，优先选择实现Runnable接口的方式</p>
<ul>
<li>实现的方式没有类的单继承性的局限性</li>
<li>实现的方式更适合来处理多个线程有共享数据的情况</li>
<li>实际上，两种方法都是重写了<strong>Runnable</strong>里的run的抽象方法</li>
</ul>
<h4 id="3-实现Callable接口"><a href="#3-实现Callable接口" class="headerlink" title="3. 实现Callable接口"></a>3. 实现Callable接口</h4><ol>
<li>创建一个实现Callable的实现类</li>
<li>实现call方法，将此线程中需要执行的操作声明在call方法中，可以有返回值</li>
<li>创建Callable接口实现类的对象</li>
<li>将此Callable接口实现类的对象作为参数传递到FutureTask构造器中，创建FutureTask的对象</li>
<li>将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread的对象，并调用start()</li>
<li>futureTask.get()获取call()的返回值</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个实现Callable的实现类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumThread</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实现call方法，将此线程中需要执行的操作声明在call方法中，可以有返回值</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadNew</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建Callable接口实现类的对象</span></span><br><span class="line">        NumThread numThread = <span class="keyword">new</span> NumThread();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将此Callable接口实现类的对象作为参数传递到FutureTask构造器中，创建FutureTask的对象</span></span><br><span class="line">        FutureTask futureTask = <span class="keyword">new</span> FutureTask(numThread);</span><br><span class="line">        <span class="comment">// 将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread的对象，并调用start()</span></span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值</span></span><br><span class="line">            Object sum = futureTask.get();</span><br><span class="line">            System.out.println(sum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>比实现Runnable接口强大原因</strong></p>
<ul>
<li>call()可以有返回值</li>
<li>call()可以抛出异常，被外面的操作捕获，获取异常的信息</li>
<li>Callable是支持泛型的</li>
</ul>
<h4 id="4-使用线程池"><a href="#4-使用线程池" class="headerlink" title="4. 使用线程池"></a>4. 使用线程池</h4><ol>
<li>提供指定线程数量的线程池</li>
<li>执行指定的线程的操作，需要提供实现Runnable接口或Callable接口实现类的对象</li>
<li>关闭连接池</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Runnable接口的实现类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Callable接口的实现类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumThread1</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实现call方法，将此线程中需要执行的操作声明在call方法中，可以有返回值</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：&quot;</span> + i);</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 提供指定线程数量的线程池</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 执行指定的线程的操作，需要提供实现Runnable接口或Callable接口实现类的对象</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> NumberThread());<span class="comment">// 适用于Runnable</span></span><br><span class="line">        service.submit(<span class="keyword">new</span> NumThread1());<span class="comment">// 适用于Callable</span></span><br><span class="line">        service.shutdown(); <span class="comment">// 关闭连接池</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优点</strong></p>
<ul>
<li>提高响应速度，减少了创建新线程的时间</li>
<li>降低资源消耗</li>
<li>便于线程管理（核心池的大小，最大线程数等等）</li>
</ul>
<hr>
<h2 id="Java常用类"><a href="#Java常用类" class="headerlink" title="Java常用类"></a>Java常用类</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p><strong>说明</strong></p>
<ol>
<li>使用一对” “一起来表示</li>
<li>String声明为final的，不可被继承</li>
<li>String实现了Serializable接口，表示字符串是支持序列化的</li>
<li>String实现了Comparable接口，表示String可以比较大小</li>
<li>String内部定义了final char[] value用于存储字符串的数据，代表不可变的字符序列（<strong>不可变性</strong>）<ul>
<li>对字符串重新赋值、连接操作、replace()方法修字符等，只要对原字符串进行修改都是需要重新指定内存区域赋值</li>
</ul>
</li>
<li>通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在<strong>字符串常量池</strong>中<ul>
<li>字面量（literal）是用于表达<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%BA%90%E4%BB%A3%E7%A0%81/3969">源代码</a>中一个固定值的表示法</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;abc&quot;</span>; <span class="comment">// 字面量的定义方式</span></span><br></pre></td></tr></table></figure>

<ol start="7">
<li>字符串常量池中不会储存相同内容的字符串</li>
</ol>
<p><strong>实例化方式</strong></p>
<ul>
<li>通过字面量定义的方式</li>
<li>通过new+构造器的方式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 通过字面量定义的方式，此时的s1和s2的数据abc声明在方法区中的字符串常量池中</span></span><br><span class="line">    String s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    String s2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="comment">// 通过new+构造器的方式，此时s3和s4保存的地址值，是在堆空间中开辟空间后对应的地址值</span></span><br><span class="line">    String s3 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    String s4 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(s1 == s2); <span class="comment">// true</span></span><br><span class="line">    System.out.println(s3 == s4); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<img src="https://wx3.sinaimg.cn/large/006GctFNgy1gpp0xxqj5zj30xq0i6n8j.jpg" alt="字符串对象储存方式" style="zoom:50%;" />



<p><strong>例子</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    String s2 = <span class="string">&quot;def&quot;</span>;</span><br><span class="line"></span><br><span class="line">    String s3 = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line">    String s4 = <span class="string">&quot;abc&quot;</span> + <span class="string">&quot;def&quot;</span>;</span><br><span class="line">    String s5 = s1 + <span class="string">&quot;def&quot;</span>;</span><br><span class="line">    String s6 = <span class="string">&quot;abc&quot;</span> + s2;</span><br><span class="line">    String s7 = s1 + s2;</span><br><span class="line">    String s8 = (s1 + s2).intern(); <span class="comment">// 调常量池已有的字符串</span></span><br><span class="line"></span><br><span class="line">    System.out.println(s3 == s4); <span class="comment">// true</span></span><br><span class="line">    System.out.println(s3 == s5); <span class="comment">// false</span></span><br><span class="line">    System.out.println(s3 == s6); <span class="comment">// false</span></span><br><span class="line">    System.out.println(s3 == s7); <span class="comment">// false</span></span><br><span class="line">    System.out.println(s3 == s8); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>说明</strong></p>
<ul>
<li>常量和常量的拼接结果在常量池，且常量池中不会存在相同内容的常量</li>
<li>只要其中有一个是变量，结果就在堆中（跟new类似）</li>
<li>如果拼接的结果调用intern()方法，返回值就在常量池中</li>
</ul>
<p><strong>String和char[]之间互相转换</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// String---&gt;char[]：调用String的toCharArray()</span></span><br><span class="line">    String s = <span class="keyword">new</span> String(<span class="string">&quot;abc123&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span>[] charArray = s.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; charArray.length; i++) &#123;</span><br><span class="line">        System.out.println(charArray[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// char[]---&gt;String，调用String的构造器</span></span><br><span class="line">    <span class="keyword">char</span>[] arr = <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line">    String s1 = <span class="keyword">new</span> String(arr);</span><br><span class="line">    System.out.println(s1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>String和byte[]之间互相转换</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//解码集和编码集要一致         </span></span><br><span class="line">    <span class="comment">// String---&gt;byte[]:调用String的getBytes()</span></span><br><span class="line">    String s = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = s.getBytes();<span class="comment">// 使用默认的字符集进行编码</span></span><br><span class="line">    System.out.println(Arrays.toString(bytes));<span class="comment">// [97, 98, 99]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// byte[]---&gt;String，调用String的构造器</span></span><br><span class="line">    String s1 = <span class="keyword">new</span> String(bytes); <span class="comment">// 使用默认的字符集进行解码</span></span><br><span class="line">    System.out.println(s1); <span class="comment">// abc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="StringBuffer和StringBuilder"><a href="#StringBuffer和StringBuilder" class="headerlink" title="StringBuffer和StringBuilder"></a>StringBuffer和StringBuilder</h3><p><strong>三者的关系</strong></p>
<ul>
<li>String：不可变的字符序列，底层</li>
<li>StringBuffer：可变的字符序列，线程安全的，效率低</li>
<li>StringBuilder：可变的字符序列，线程不安全的，效率高（jdk5.0新增）</li>
</ul>
<p><strong>源码分析</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(); <span class="comment">// char[] value = new char[0];</span></span><br><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>); <span class="comment">// char[] value = new char[]&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;;</span></span><br><span class="line"></span><br><span class="line">StringBuffer sb1 = <span class="keyword">new</span> StringBuffer(); <span class="comment">// char[] value = new char[16]; // 底层创建了一个长度为16的数组</span></span><br><span class="line">sb1.append(<span class="string">&#x27;a&#x27;</span>); <span class="comment">// value[0] = &#x27;a&#x27;;</span></span><br><span class="line">sb1.append(<span class="string">&#x27;b&#x27;</span>); <span class="comment">// value[1] = &#x27;b&#x27;;</span></span><br><span class="line">StringBuffer sb2 = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;abc&quot;</span>); <span class="comment">// char[] value = new char[&quot;abc&quot;.length() + 16];</span></span><br></pre></td></tr></table></figure>

<p><em>注意</em></p>
<ul>
<li>System.out.println(sb.length()); // 3</li>
<li>扩容：如果要添加的数据底层数组盛不下，那就需要扩容底层的数组；默认情况下，扩容为原来容量的2倍 + 2，同时将原有数组的元素复制到新的数组中</li>
<li>开发中，已知大概数组大小，可以提前使用StringBuffer(int capacity)造个大小差不多的数组，避免复制，提高效率</li>
</ul>
<p><strong>常用方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StringBuffer <span class="title">append</span><span class="params">(xxx)</span>:用于字符串的拼接</span></span><br><span class="line"><span class="function">StringBuffer <span class="title">delete</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span>:删除指定位置的内容</span></span><br><span class="line"><span class="function">StringBuffer <span class="title">replace</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, String str)</span>:把[start, end]位置替换成str </span></span><br><span class="line"><span class="function">StringBuffer <span class="title">insert</span><span class="params">(<span class="keyword">int</span> offset， xxx)</span>:在指定位置插入xxx    </span></span><br><span class="line"><span class="function">StringBuffer <span class="title">reverse</span><span class="params">(xxx)</span>:把当前字符串序列反转   </span></span><br></pre></td></tr></table></figure>



<h3 id="有关Date的类"><a href="#有关Date的类" class="headerlink" title="有关Date的类"></a>有关Date的类</h3><h4 id="JDK1-8之前"><a href="#JDK1-8之前" class="headerlink" title="JDK1.8之前"></a>JDK1.8之前</h4><ul>
<li><strong>java.util.Date</strong></li>
<li><strong>java.sql.Date</strong>（是util.Date的子类）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateTimeTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.System类中的currentTimeMillis()</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 返回当前时间与1970年1月1日0：0：0之间以毫秒为单位的时间差</span></span><br><span class="line">        <span class="comment">// 称为时间戳</span></span><br><span class="line">        <span class="keyword">long</span> l = System.currentTimeMillis();</span><br><span class="line">        System.out.println(l);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. java.util.Date</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 构造器1：date()，创建了一个对应当前时间的Date对象</span></span><br><span class="line">        Date date1 = <span class="keyword">new</span> Date();</span><br><span class="line">        System.out.println(date1.toString()); <span class="comment">// Mon Apr 19 22:46:43 CST 2021</span></span><br><span class="line">        System.out.println(date1.getTime()); <span class="comment">// 获取当前date对象的时间戳</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//构造器2：创建指定毫秒数的date对象</span></span><br><span class="line">        Date date2 = <span class="keyword">new</span> Date(<span class="number">1618843665359L</span>);</span><br><span class="line">        System.out.println(date2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造器：java.sql.Date</span></span><br><span class="line">        java.sql.Date date3 = <span class="keyword">new</span> java.sql.Date(<span class="number">1618843665359L</span>);</span><br><span class="line">        System.out.println(date3);</span><br><span class="line">        <span class="comment">// java.sql.Date---&gt;java.util.Date</span></span><br><span class="line">        java.sql.Date date4 = <span class="keyword">new</span> java.sql.Date(date2.getTime()); <span class="comment">// 获取util.Date对象的时间戳，再放到sql.Date类的构造器中</span></span><br><span class="line">        System.out.println(date4.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>SimpleDateFormat</strong></li>
</ul>
<p><em>对SimpleDateFormat对日期Date类的格式化和解析</em>(解析和格式化的标准要统一！)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFormatDateTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestSimpleDateFormat</span><span class="params">()</span> <span class="keyword">throws</span> ParseException </span>&#123;<span class="comment">// 要抛异常</span></span><br><span class="line">        <span class="comment">// 实例化SimpleDateFormat:使用默认的构造器</span></span><br><span class="line">        SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat();</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line"><span class="comment">//        System.out.println(date);</span></span><br><span class="line">        <span class="comment">// 格式化：日期---&gt;字符串</span></span><br><span class="line">        String format = sdf.format(date);</span><br><span class="line">        System.out.println(format);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 格式化逆过程，字符串---&gt;日期</span></span><br><span class="line">        String str = <span class="string">&quot;21-7-21 上午10:16&quot;</span>;</span><br><span class="line">        Date parse = sdf.parse(str);</span><br><span class="line">        System.out.println(parse);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以指定的时间格式解析和格式化，调用带参的构造器，具体看API内容</span></span><br><span class="line">        SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line">        String format1 = simpleDateFormat.format(date);</span><br><span class="line">        System.out.println(format1); <span class="comment">// 2021-04-21 09:28:22</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Calendar</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Calendar日历类（抽象类）的使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CalendarTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1.实例化</span></span><br><span class="line">    <span class="comment">// 方式1：创建子类GregorianCalendar的对象</span></span><br><span class="line">    <span class="comment">// 方式2：调用其静态方法getInstance</span></span><br><span class="line">    Calendar instance = Calendar.getInstance();</span><br><span class="line">    <span class="comment">// 2.常用方法</span></span><br><span class="line">    <span class="comment">// get()</span></span><br><span class="line">    <span class="keyword">int</span> days = instance.get(Calendar.DAY_OF_YEAR);</span><br><span class="line">    System.out.println(days);</span><br><span class="line">    <span class="comment">// set()</span></span><br><span class="line">    instance.set(Calendar.DAY_OF_YEAR, <span class="number">165</span>);</span><br><span class="line">    days = instance.get(Calendar.DAY_OF_YEAR);</span><br><span class="line">    System.out.println(days);</span><br><span class="line">    <span class="comment">// add(),在原有基础上加了多少</span></span><br><span class="line">    instance.add(Calendar.DAY_OF_WEEK, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getTime()日历类---&gt;Date类</span></span><br><span class="line">    Date date = instance.getTime();</span><br><span class="line">    System.out.println(date);</span><br><span class="line">    <span class="comment">// setTime()Date类---&gt;日历类</span></span><br><span class="line">    instance.setTime(date);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="JDK1-8新增"><a href="#JDK1-8新增" class="headerlink" title="JDK1.8新增"></a>JDK1.8新增</h4><ul>
<li><strong>LocalDate、LocalTime、LocalDateTime</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LocalTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// LocalDate,LocalTime,LocalDateTime使用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// now()获取当前的日期和时间</span></span><br><span class="line">    LocalDate localDate = LocalDate.now();<span class="comment">// 2021-04-21</span></span><br><span class="line">    LocalTime localTime = LocalTime.now();<span class="comment">// 10:13:07.270</span></span><br><span class="line">    LocalDateTime localDateTime = LocalDateTime.now();<span class="comment">// 2021-04-21T10:13:07.270</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// of():设定指定的年月日时分秒，没有偏移量</span></span><br><span class="line">    LocalDateTime dateTime = LocalDateTime.of(<span class="number">2021</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">45</span>);</span><br><span class="line">    System.out.println(dateTime);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getXxx() 获取相应的一些属性</span></span><br><span class="line">    System.out.println(localDateTime.getDayOfMonth());</span><br><span class="line">    <span class="comment">// withXxx,设置相应的属性，会返回一个新对象，体现了不可变性</span></span><br><span class="line">    LocalDate date = localDate.withDayOfMonth(<span class="number">13</span>);</span><br><span class="line">    System.out.println(date);</span><br><span class="line">    System.out.println(localDate);</span><br><span class="line">    <span class="comment">// plusXxx</span></span><br><span class="line">    LocalDate plus = localDate.plusDays(<span class="number">12</span>);</span><br><span class="line">    System.out.println(plus);</span><br><span class="line">    System.out.println(localDate);</span><br><span class="line">    <span class="comment">// minusXxx</span></span><br><span class="line">    LocalDate minus = localDate.minusDays(<span class="number">12</span>);</span><br><span class="line">    System.out.println(minus);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Instant</strong></li>
</ul>
<p><em>类似于java.util.Date类</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InstantTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// now()获取本初子午线对用的标准时间</span></span><br><span class="line">    Instant instant = Instant.now();</span><br><span class="line">    System.out.println(instant);</span><br><span class="line">    <span class="comment">// 添加时间的偏移量</span></span><br><span class="line">    OffsetDateTime offsetDateTime = instant.atOffset(ZoneOffset.ofHours(<span class="number">8</span>));</span><br><span class="line">    System.out.println(offsetDateTime);</span><br><span class="line">    <span class="comment">// 获取自1970年0：0：0开始的毫秒数 ---&gt;Date类的gettime()</span></span><br><span class="line">    <span class="keyword">long</span> l = instant.toEpochMilli();</span><br><span class="line">    System.out.println(l);</span><br><span class="line">    <span class="comment">// ofEpochMilli,通过给定的毫秒数，获取Instant实例 ---&gt;Date(millis)</span></span><br><span class="line">    Instant ofEpochMilli = Instant.ofEpochMilli(<span class="number">161897569439L</span>);</span><br><span class="line">    System.out.println(ofEpochMilli);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Comparable（自然排序）"><a href="#Comparable（自然排序）" class="headerlink" title="Comparable（自然排序）"></a>Comparable（自然排序）</h3><ul>
<li><p>像String、包装类实现了Comparable接口，重写了compareTo(obj)的方法，给出了比较两个对象的大小的方式（一般是从小到大排），用Arrays.sort(Object o)实现排序</p>
</li>
<li><p>重写compareTo(obj)规则：</p>
<ul>
<li>如果当前对象this大于形参对象obj，返回正整数，小于返回负整数，等于返回零</li>
</ul>
</li>
<li><p>对于自定义类来说，如果需要排序，可以让自定义类实现Coparable接口，重写compareTo(obj)的方法，在方法中指明如何排序</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Goods[] arr = <span class="keyword">new</span> Goods[<span class="number">4</span>];</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;lenovo&quot;</span>, <span class="number">3544</span>);</span><br><span class="line">    arr[<span class="number">1</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;mi &quot;</span>, <span class="number">5434</span>);</span><br><span class="line">    arr[<span class="number">2</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;Huawei&quot;</span>, <span class="number">5434</span>);</span><br><span class="line">    arr[<span class="number">3</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;dell&quot;</span>, <span class="number">8534</span>);</span><br><span class="line"></span><br><span class="line">    Arrays.sort(arr);</span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">    <span class="comment">// out: [Goods&#123;name=&#x27;lenovo&#x27;, price=3544.0&#125;, Goods&#123;name=&#x27;Huawei&#x27;, price=5434.0&#125;,</span></span><br><span class="line">    <span class="comment">// Goods&#123;name=&#x27;mi &#x27;, price=5434.0&#125;, Goods&#123;name=&#x27;dell&#x27;, price=8534.0&#125;]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//*****************************************************************</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Goods</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line">    <span class="comment">// 实现了Comparable的接口里的compareTo的方法</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Goods</span><span class="params">(String name, <span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Goods&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, price=&quot;</span> + price +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> <span class="keyword">throws</span> RuntimeException </span>&#123;</span><br><span class="line">        <span class="comment">// 方式1</span></span><br><span class="line">        <span class="keyword">if</span>(o <span class="keyword">instanceof</span> Goods)&#123;</span><br><span class="line">            Goods goods = (Goods) o;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.price &gt; goods.price)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.price &lt; goods.price)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//return 0;</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.name.compareTo(goods.name);<span class="comment">// 如果价钱一样，按照姓名排序</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 方式2</span></span><br><span class="line">            <span class="comment">//Double.compare(this.price, goods.price);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;传入的数据类型不一致！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="Comparator（定制排序）"><a href="#Comparator（定制排序）" class="headerlink" title="Comparator（定制排序）"></a>Comparator（定制排序）</h3><ul>
<li>元素的类型没有实现Comparable接口而又不方便修改代码，或实现了Comparable接口的排序规则不适合当前的操作，可以考虑使用Comparator的对象来排序</li>
<li>重写compare(Object o1, Object o2)方法，比较o1和o2的大小，如果方法返回正整数，o1&gt;o2；返回负整数，o1&lt;o2；返回零，表示二者相等</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// Goods类结构和上面一样</span></span><br><span class="line">    Goods[] arr = <span class="keyword">new</span> Goods[<span class="number">5</span>];</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;lenovo&quot;</span>, <span class="number">3544</span>);</span><br><span class="line">    arr[<span class="number">1</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;mi &quot;</span>, <span class="number">5434</span>);</span><br><span class="line">    arr[<span class="number">2</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;Huawei&quot;</span>, <span class="number">5434</span>);</span><br><span class="line">    arr[<span class="number">3</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;dell&quot;</span>, <span class="number">8534</span>);</span><br><span class="line">    arr[<span class="number">4</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;dell&quot;</span>, <span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">    Arrays.sort(arr, <span class="keyword">new</span> Comparator() &#123;<span class="comment">// 匿名类的匿名对象</span></span><br><span class="line">        <span class="comment">// 指明商品比较大小的方式，按照产品名称从低到高排序，再按价格从高到低排序</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> Object &amp;&amp; o2 <span class="keyword">instanceof</span> Object)&#123;</span><br><span class="line">                Goods g1 = (Goods) o1;</span><br><span class="line">                Goods g2 = (Goods) o2;</span><br><span class="line">                <span class="keyword">if</span>(g1.getName().equals(g2.getName()))&#123;</span><br><span class="line">                    <span class="keyword">return</span> -Double.compare(g1.getPrice(), g2.getPrice()); <span class="comment">// 加负号使得其从高往低排</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> g1.getName().compareTo(g2.getName());<span class="comment">// 字符串从低往高排</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;传入的数据类型不一致！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Comparable和Comparator对比</strong></p>
<p>Comparable接口的方式一旦确定，保证Comparable接口实现类对象在任何位置都可以比较大小；而Comparator接口属于临时性的比较</p>
<hr>
<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><ul>
<li>ArrayList是Java内置的数据集合，用于存储多个数据</li>
<li>ArrayList是数组的替代品，使用更简单，提供了更多的数据操作方法</li>
<li>ArrayList几乎是每个项目中必备的类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ArrayLis元素可以不一样，但是是不正确使用！</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListSample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        </span><br><span class="line">        List&lt;String&gt; bookList = <span class="keyword">new</span> ArrayList&lt;String&gt;();<span class="comment">//&lt;泛型&gt;，用来规范列表中的数据类型</span></span><br><span class="line">        bookList.add(<span class="string">&quot;红楼梦&quot;</span>);<span class="comment">//添加元素</span></span><br><span class="line">        bookList.add(<span class="string">&quot;西游记&quot;</span>);</span><br><span class="line">        String name = bookList.get(<span class="number">1</span>);<span class="comment">//通过索引得到元素</span></span><br><span class="line">        <span class="keyword">int</span> size = bookList.size();<span class="comment">//获取list大小</span></span><br><span class="line">        bookList.remove(<span class="number">1</span>);<span class="comment">//通过索引删除元素</span></span><br><span class="line">        <span class="keyword">for</span>(String book : bookList)&#123; <span class="comment">//遍历list中元素的方法</span></span><br><span class="line">            System.out.println(book);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


    </div>
    <div>
      
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>

      
    </div>
	
	
    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/03/29/Python%E8%A1%A5%E7%A5%A8/" rel="prev" title="Python补票">
      <i class="fa fa-chevron-left"></i> Python补票
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>


      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="nav-number">1.1.</span> <span class="nav-text">基础概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%A3%B0%E6%98%8E%E5%91%A8%E6%9C%9F"><span class="nav-number">1.1.1.</span> <span class="nav-text">线程的声明周期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Thread%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B8%B8%E9%87%8F%E5%92%8C%E6%96%B9%E6%B3%95"><span class="nav-number">1.1.2.</span> <span class="nav-text">Thread中常用的常量和方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6"><span class="nav-number">1.1.3.</span> <span class="nav-text">同步机制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.2.</span> <span class="nav-text">创建多线程的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E7%BB%A7%E6%89%BFThread%E7%B1%BB"><span class="nav-number">1.2.1.</span> <span class="nav-text">1. 继承Thread类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.2.2.</span> <span class="nav-text">2. 实现Runnable接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%AE%9E%E7%8E%B0Callable%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.2.3.</span> <span class="nav-text">3. 实现Callable接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">1.2.4.</span> <span class="nav-text">4. 使用线程池</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="nav-number">2.</span> <span class="nav-text">Java常用类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#String"><span class="nav-number">2.1.</span> <span class="nav-text">String</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#StringBuffer%E5%92%8CStringBuilder"><span class="nav-number">2.2.</span> <span class="nav-text">StringBuffer和StringBuilder</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E5%85%B3Date%E7%9A%84%E7%B1%BB"><span class="nav-number">2.3.</span> <span class="nav-text">有关Date的类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JDK1-8%E4%B9%8B%E5%89%8D"><span class="nav-number">2.3.1.</span> <span class="nav-text">JDK1.8之前</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JDK1-8%E6%96%B0%E5%A2%9E"><span class="nav-number">2.3.2.</span> <span class="nav-text">JDK1.8新增</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Comparable%EF%BC%88%E8%87%AA%E7%84%B6%E6%8E%92%E5%BA%8F%EF%BC%89"><span class="nav-number">2.4.</span> <span class="nav-text">Comparable（自然排序）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Comparator%EF%BC%88%E5%AE%9A%E5%88%B6%E6%8E%92%E5%BA%8F%EF%BC%89"><span class="nav-number">2.5.</span> <span class="nav-text">Comparator（定制排序）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ArrayList"><span class="nav-number">3.</span> <span class="nav-text">ArrayList</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="KK"
      src="/images/main.jpg">
  <p class="site-author-name" itemprop="name">KK</p>
  <div class="site-description" itemprop="description">记录生活中的点点滴滴~</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>


<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1811921555&auto=1&height=66"></iframe>



    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">KK</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">41k</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div><script color="0,0,255" opacity="0.5" zIndex="-1" count="99" src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js"></script>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body>
</html>

<a target="_blank" rel="noopener" href="https://github.com/52Hz-Kun" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/click.js"></script>